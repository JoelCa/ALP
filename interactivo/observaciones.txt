Dependencias (Viejo)

cabal install mtl
cabal install exceptions


Observaciones

- El caracter "\", se identifica con el char '\\'.
CUIDADO!. Si se quiere probar el parser por el interprete hacer "\\" en lugar de "\".
Ej: getCommand ("Theorem a : a /\\ a.") []

- (YA NO VALE, arreglado) Emplee unificación de solo un nivel, por ejemplo esto no se puede probar:
  Theorem qqq: p->(forall p, forall p, p) -> forall p, p.

- Problema dado por Mauro en agda: ~(A <-> ~A)
Resuelto en Coq.

Theorem paradox: ~(A <-> ~A).
Proof.
  unfold iff, not.
  intros.
  elim H.
  intros;
  apply H0;
  apply H1;
  intro;
  apply H0;
  assumption;
  assumption.
Qed.

- YA NO VALE. Cuando se aplica la introducción del "para todo" sobre la variable de tipo "x", se reemplaza
en el tipo sin nombre el término "TBound 0" por "TFree x". Es util cuando se comparan tipos
en el comando "assumption".


- El lambda término final tiene un tipo alpha equivalente al dado por el usuario.
Por ejemplo, si el tipo es: (forall k, k -> k) -> (forall j, j) -> (forall y, y).
Se tiene el lambda término \x:(forall k, k -> k).x (forall j, j), el cual tendría tipo
(forall k, k -> k) -> (forall j, j) -> (forall j, j)

- Definimos cada una de la reglas de la semántica de tipos del sistema F, mediante términos con aujeros.
De modo tal que sucesivas aplicaciones de los axiomas terminen de armar el lambda término que cumpla
con el tipo deseado. 
Sabemos que el sistema F, permite la abstracción tanto términos como tipos. Así podemos definir nuevos 
constructores de tipos, a partir del lenguaje, sin necesidad de incoorporarlo ad hoc.
Hacemos uso del poder expresivo del sistema F, definiendo los tipos (u operadores lógicos) "and" y "or",
en término de los tipos del sistema F.

- ¿Por qué es necesario declarar las proposiciones (o variables de tipo)?. Lo hacemos para tener un
un mejor algoritmo de reescritura de variables de tipos ligadas sobre el tipo que da el usuario.

- Casos de pruebas para el inferidor de tipos:
Válidos:
infer \d.\a.\x: a -> d.\b.\y:b.x.
infer \a.\b.\x:a->b.\c.\y:a->c.\d.\z:a->b.y.
infer \a.\b.\w:a->b.(\c.\x:a->c.\d.\y:forall o, d->c. y [d]) [a].

Inválidos:
infer (\a.\x:a.\a.\b.\y:a->b. (y) x).

- El inferidos de tipo permite superposición de variables ligadas.
Por ej: infer \a.\x:a.\a.\b.\y:a->b. (y) x.

- Aquellas variables de tipo que declaramos, mediante el comando "Props", aparecen como variables
de tipo libre en el lambda término que las utiliza.

- La unificación, con el comando "apply", sobre una variable de término H, trata de unificar 
todos los "para todos" seguidos más externos de H. En algunos casos, basta con encontrar la 
unificación solo para algunos "para todos".

- Utilizé las estructuras de datos Map y Seq.

- Utilizé el tipo de datos Doc, como pretty printer.

- Casos para probar la definición de tipos:
Definition c1 x := ~(x /\  (forall w, w)) \/ x.
(Hacer un teorema).

- Tanto "~" como "<->", están definidos de manera "hardcode".

- Los operadores pueden identificarse de dos formas:
1. Alfanuméricamente. Es este caso el operador por default es prefix.
Se usa `id` para que sea prefix.
2. Simbólicamente. Por default es prefix. Se usar (id), para que sea prefix.
Gramática de símbolos:
symbol  ->  ascSymbol | uniSymbol<special | _ | : | " | '>
ascSymbol ->  ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @
  |   \ | ^ | | | - | ~
uniSymbol ->  any Unicode symbol or punctuation 

- Funcionamiento del algoritmo que controla la eliminación y creación de subpruebas.
Cuando se crean n subpruebas, con n > 1, que le corresponden los tipos t_1, .., t_n.
A la cabeza de la lista de subpruebas (subps), p_h, se le asignan los tipos t_2, ..., t_n.
Además, se añade una nueva prueba p_1 con el tipo t_1.

Cuando la prueba que se encuentra a la cabeza de la lista subps, p_1, termina, puede suceder
dos cosas. Consideramos a p_t como la cola de subps.
1. Si p_t = [], no hay más subpruebas.
2. Si no p_t = p_h : p_t'.Luego, se extrae p_1 de subps, y pueden suceder dos cosas:
 1. Si p_h tiene asignado un solo tipo, no se hace nada.
 2. Si p_h tiene los tipos t_1, .. t_2, se quita t_1 de los tipos asignados a p_h, 
y se añade una nueva prueba p_2 con el tipo t1.

