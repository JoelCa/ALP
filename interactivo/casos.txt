Casos probados:

Props p q.

Casos con existenciales:
- Theorem t1 : (forall x, x -> x) -> (exists x, x -> x) -> (exists x, x -> x).
Para chequear que el para todo unifica con el existe.
- Theorem t2 : p -> (exists x, p -> x) -> (exists y, y).
Para chequear eliminación de existe. ARREGLAR pretty printer del término. (VER)
- Theorem t3: (exists y, forall x, x -> y) -> (forall x, exists y, x -> y).
Para chequear eliminación de existe. NO chequee el lambda termino.

Cason sin existenciales:
- Theorem t4: (forall x, forall y, forall z, y -> y) -> (p -> p).
Para ver que los tipos "vacios" se instancian correctamente.
- Theorem t5: (forall a, (forall c, a)  -> (forall c, a)) -> (forall c, p) -> (forall c, p).
Arreglado. Cambiamos la forma con que se añadían las susbtituciones a la estructura Map.
- Theorem t6: (forall a, forall b, a -> b) -> p -> q.
Arreglado. Se Generaba un lambda término con las instancias al reves. La solución es es la misma
del teorema t5.
- Theorem t7: forall as, forall we, as -> (forall jk, jk) -> we.
Para chequear que se imprima bien el lambda término.
- Theorem t8 : (forall qw, qw /\ qw) -> forall nm, nm /\ nm.
Para chequear que se imprima bien el lambda término.
- Theorem t9 : p -> q -> (p /\ (p /\ q)) /\ q.
Para chequear que funcione bien el algoritmo que maneja la construcción de las subpruebas.
- Props p q r t y.
  Theorem t10: p -> q -> r -> t -> (p -> q -> r -> t -> y) -> y.
Para chequear el pretty printer de las subpruebas, con el nuevo algoritmo.
¿Qué hacer cuando variable de tipo es el igual a variable de término? NO hay problema.
- Theorem t11: (forall b, (forall a, a) -> (forall w, forall r, b) -> b) -> 
    (forall o, forall w, (forall x, x) -> (forall dd, forall ee, (forall zz, o)) -> (forall kk, o)).
Para probar la unificación y el pretty printer.
- Theorem t12: forall a, forall b, (a -> b) -> (forall c, forall d, a -> b).
Para probar el comando apply.
- Theorem t13: forall o, (forall b, (forall a, a) -> (forall c, forall d, b) -> b) -> (forall a, a) -> (forall w, forall r, (forall t, o /\ t)) -> (forall t, o /\ t).
Para probar la unificación.
- Theorem t14: forall d, (forall a, a -> d)-> forall b, forall c, b -> d.
Para probar la unificación.
- Theorem t15: forall b, forall c, (forall a, a -> c) -> b -> c.
Para probar la unificación.
-Theorem t16: forall b, forall c, (forall a, a -> c) -> forall qq, (forall h, h -> c).
Para probar la unificación.
- Theorem tt17 : forall a, forall b, a /\ b -> a.
  Theorem tt17' : forall p, forall q, forall r, p /\ q -> (p -> r) -> r.
Para probar el comando exact en la prueba de tt17', de la siguiente manera:
exact (H1 (tt17 [p] [q] H0)).
- Theorem t18: (forall x, forall y, forall z, x -> z) -> (forall x, forall z, x -> z). 
Para chequear si podemos instanciar el tipo "vacio", mediante "exact".
- Definition <-> x y := (x -> y) /\ (y -> x) (infix).
  Theorem t19 : forall x, forall y, x /\ y -> x <-> y.
Para chequear la definición de operandos.
- Definition <-> x y := (x -> y) /\ (y -> x) (infix).
  Theorem t20: forall g, forall w, (g <-> w) -> (g -> w).
Para chequear la definición de operandos.
- Definition -- x y := forall w, (w /\ x) /\ y -> w (infix).
  Theorem t21: forall w, forall p, w -> p -> (forall p, p /\ w \/ w) -- (forall w, forall p, w /\ p).
Para chequear el renombre de variables de tipo ligadas en el unfold.
- Definition ^ x y := forall w, forall v, x /\ y /\ w \/ v -> x /\ y (infix).
  Theorem t22: forall w, forall v, w -> v -> w ^ (forall v, forall w, v -> w).
Para chequear el renombre de variables de tipo ligadas en el unfold.
-- Theorem t23 : forall o, forall t, (forall w,  forall r, o /\ w) -> (o /\ t).
Para chequear la unificación (este caso no unificaba y lo arregle).
