\documentclass[a4paper,11pt]{article}
\usepackage[left=1.5cm,top=2.0cm,right=1.5cm,bottom=2.0cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{prooftree}
\usepackage{enumitem}
\usetikzlibrary{positioning, babel,shapes}
\newdimen\nodeDist
\nodeDist=35mm

\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{}
\author{}

\begin{document}

\maketitle

\begin{center}
\section*{Análisis de lenguajes de programación} 
\subsection*{Asistente de prueba de la lógica proposicional constructiva de segundo orden}
\end{center}

\newpage{\pagestyle{empty}\cleardoublepage}


\section{Motivación}
Era de especial intereses para el autor entender la relación entre la lógica y el lambda cálculo.
De ahi que se le ocurre implementar un asistente de prueba. Se decide utilizar la correspondencia
que existe entre el Sistema F, y la lógica proposicional constructiva de segundo orden.
 
\section{Fórmulas como tipos}
Podemos interpretar $M : \sigma$ de dos formas:
\begin{itemize}
  \item Término como programa, tipo como especificación: $M$ es una función de tipo $\sigma$.
  \item Tipo como una fórmula, término como su prueba: $M$ es una prueba de la fórmula $\sigma$.
\end{itemize}

La correspondencia Curry-Howard fórmulas como tipos, es una correspondencia uno a uno entre términos
tipados del lambda cálculo y las derivaciones en la lógica proposicional minimal.
Desde el punto de vista de la lógica: $x_{1}:\tau_{1}, x_{2}:\tau_{2}, \ldots, x_{n}:\tau_{n} \vdash M : \sigma$,
puede leerse como $M$ es una prueba de $\sigma$ a partir de las hipótesis $\tau_{1}, \tau_{2}, \ldots, \tau_{n}$.

\paragraph{Definición.}  El sistema de lógica proposional minimal $PROP$ consiste de:



\begin{itemize}
  \item La siguiente sintaxis abstracta:
  
  $prop ::= PropVar | (prop \rightarrow prop)$.
  
  \item Reglas de derivación. Donde $\Delta$ es un conjunto de proposiciones, $\sigma$ y $\tau$ son proposiciones.
   
  \begin{minipage}[t]{0.4\linewidth}

  \begin{prooftree}
    \Gamma \vdash n:\mathbb{N} \hspace{0.5cm}
    \Gamma \vdash xs:\mathbb{N}^{*}
  \using
    {\scriptsize \textsc{T-CONS}}
    \justifies
    \Gamma \vdash cons \ n \ xs : \mathbb{N}^{*}
  \end{prooftree}
   
  \end{minipage}

  \begin{minipage}[t]{0.5\linewidth}

  \end{minipage}

\end{itemize}
















\section{Data types}

\begin{verbatim}
data ProverState = PSt { proof :: Maybe ProofState
                       , global :: ProverGlobal
                       }
\end{verbatim}

Estado general del asistente.
\begin{itemize}
  \item \texttt{proof}: representa a la prueba que construye el usuario, si existe.
  \item \texttt{global}: datos globales.
\end{itemize}

\begin{verbatim}
data ProverGlobal = PGlobal { fTypeContext :: FTypeContext
                            , teorems :: Teorems
                            , opers :: FOperations
                            }
\end{verbatim}

Este registro contiene los datos globales del asistente.
\begin{itemize}
  \item \texttt{fTypeContext}: variables de tipo libres.
  \item \texttt{teorems}: teoremas probados. Consiste en una lista de pares clave-valor.
  Donde la clave es el nombre del teorema, y el valor es el lambda término de la prueba,
  el cual tiene asociado su tipo mediante el constructor \texttt{as}.
  \item \texttt{opers}: representa a las operaciones que pueden desplegarse.
\end{itemize}

\begin{verbatim}
data ProofState = PState { name :: String
                         , types :: (Type,TType)
                         , constr :: ProofConstruction
                         }
\end{verbatim}

Estado general de la prueba que realiza el usuario.
\begin{itemize}
  \item \texttt{name}: nombre de la prueba.
  \item \texttt{types}: tipo, con y sin nombres, que se quiere habitar. Se corresponde a fórmula que quiere probar el usuario.
  \item \texttt{constr}: construcción de la prueba.
\end{itemize}

\begin{verbatim}
data ProofConstruction = PConstruction { tsubp :: Int
                                       , subps :: [SubProof]
                                       , cglobal :: ProverGlobal
                                       , term :: [SpecialTerm]
                                       }
\end{verbatim}

Prueba que realiza el usuario.
\begin{itemize}
  \item \texttt{tsubp}: cantidad total de subpruebas activas.
  \item \texttt{subps}: mantiene a todas las subpruebas activas.
  \item \texttt{cglobal}: datos globales vigentes durante la construcción de la prueba.
  \item \texttt{term}: representa al lambda término que va formando el usuario.
\end{itemize}

\begin{verbatim}
data SubProof = SP { termContext :: TermContext
                   , bTypeContext :: BTypeContext
                   , lsubp :: Int
                   , tvars :: Int
                   , ty :: [Maybe (Type, TType)]
                   }
\end{verbatim}

Representa a un conjunto de subpruebas.
Consideramos que todas ellas tienen el mismo contexto, comparten tanto los campos \texttt{termContext} como \texttt{bTypeContext}.
\begin{itemize}
  \item \texttt{termContext}: contexto de las variables de término.
  \item \texttt{bTypeContext}: contexto de las variables de tipo ligadas. Nos referimos a las variables que corresponden a una cuantificación.
  \item \texttt{lsubp}: indica la cantidad de subpruebas que contiene.
  \item \texttt{tvars}: cantidad total de variables de tipo ligadas, y variables de términos.
  \item \texttt{ty}: tipos objetivos de cada subprueba.
\end{itemize}


Utilizamos el siguiente AST para representar a un lambda término:
\begin{verbatim}
  data Term  = Bound Int
             | Free Name 
             | Term :@: Term
             | Lam (Type,TType) Term
             | BLam Var Term
             | Term :!: (Type,TType)
\end{verbatim}
  
Donde, \texttt{Type} es el AST de los tipos, y \texttt{TType} es el AST de los tipos sin nombres, es decir que estos emplean la notación De Bruijn.
\texttt{Type} nos es útil a la hora de imprimir en pantalla el tipo del lambda término, de modo tal que tenga casi el mismo tipo ingresado por el usuario 
(posible renombramiento de tipos).
Mientras que, \texttt{TType} lo usamos en todas las operatorias sobre los tipos de los lambda términos, por ejemplo, en la unificación de tipos, que
se realiza cuando se aplica la regla de eliminación del \textbf{para todo}.

A continuación, explicamos el data type utilizado para representar al lambda término que se construye de manera interactiva por el usuario.

\begin{verbatim}
data SpecialTerm = HoleT (Term->Term) | DoubleHoleT (Term->Term->Term) |
                   Term Term | TypeH TypeHole

data TypeHole = HTe ((Type, TType) -> Term) | HTy ((Type, TType) -> TypeHole)
\end{verbatim}

El data type \texttt{SpecialTerm} representa a un lamba término que puede tener dos tipos de agujero: lambda términos o tipos, de manera
exclusiva, es decir solo puede tener un solo tipo de agujero.

El data type \texttt{TypeHole} representa agujeros de tipos en un lambda término.

\section{Gramáticas}
 Gramática del lambda calculo.

\begin{tabbing}
$\langle lamterm \rangle$ \= $::=$ $\langle abs \rangle$ | $\langle term \rangle$ ( $\langle abs \rangle$ | $\varepsilon$ ) \\

$\langle term \rangle$ \> $::=$ $\langle term \rangle$ ($\langle unitterm \rangle$ | $\varepsilon$) \\

$\langle unitterm \rangle$ \> $::=$ \texttt{'('} $\langle lambterm \rangle$ \texttt{')'} |
$\langle var \rangle$ | $\langle unitterm \rangle$ \texttt{'['} $\langle typeterm \rangle$ \texttt{']'}\\

$\langle abs \rangle$ \> $::=$ \texttt{'$\lambda$'} $\langle var \rangle$ ( \texttt{':'} $\langle typeterm \rangle$ \texttt{'.'} $\langle lamterm \rangle$
| \texttt{'.'} $\langle lamterm \rangle$)
\end{tabbing}

Consideramos a $\langle var \rangle$, como la gramática de palabras alfanuméricas, incluido el guión bajo, exceptuando
las palabras reservadas: $Theorem$, $Definition$, $forall$, $False$.

Gramática del lambda calculo, sin recursión a izquierda.

\begin{tabbing}
$\langle lamterm \rangle$ \= $::=$ $\langle abs \rangle$ | $\langle term \rangle$ ( $\langle abs \rangle$ | $\varepsilon$ ) \\

$\langle term \rangle$ \> $::=$ $\langle unitterm \rangle$ $\langle term' \rangle$ \\

$\langle term' \rangle$ \> $::=$  $\langle unitterm \rangle$  $\langle term' \rangle$ | $\varepsilon$ \\

$\langle unitterm \rangle$ \> $::=$ $\langle unit \rangle$ $\langle unitterm' \rangle$ \\

$\langle unitterm' \rangle$ \> $::=$ \texttt{'['} $\langle typeterm \rangle$ \texttt{']'} $\langle unitterm' \rangle$ | $\varepsilon$ \\

$\langle unit \rangle$ \> $::=$ \texttt{'('} $\langle lambterm \rangle$ \texttt{')'} | $\langle var \rangle$ \\

$\langle abs \rangle$ \> $::=$ \texttt{'$\lambda$'} $\langle var \rangle$ ( \texttt{':'} $\langle typeterm \rangle$ \texttt{'.'} $\langle lamterm \rangle$
| \texttt{'.'} $\langle lamterm \rangle$)
\end{tabbing}

Gramática de fórmulas o tipos.

\begin{tabbing}
$\langle typeterm \rangle$ \= $::=$ $\langle unit_{1} \rangle$ \texttt{'<->'} $\langle typeterm \rangle$ | $\langle unit_{1}' \rangle$\\
$\langle unit_{1}' \rangle$ \= $::=$ $\langle unit_{2} \rangle$ ( \texttt{'->'} $\langle unit_{1}' \rangle$ | $\varepsilon$ ) 
| \texttt{'forall'} $\langle var \rangle$ \texttt{'.'} $\langle typeterm \rangle$\\
$\langle unit_{1} \rangle$ \= $::=$ $\langle unit_{2} \rangle$ ( \texttt{'->'} $\langle unit_{1} \rangle$ | $\varepsilon$ ) \\
$\langle unit_{2} \rangle$ \= $::=$ $\langle unit_{3} \rangle$ ( \texttt{'$\vee$'} $\langle unit_{2} \rangle$ | $\varepsilon$ ) \\
$\langle unit_{3} \rangle$ \= $::=$ $\langle infixOps \rangle$ ( \texttt{'$\wedge$'} $\langle unit_{3} \rangle$ | $\varepsilon$ ) \\
$\langle unit_{4} \rangle$ \= $::=$ $\langle unit_{5} \rangle$ | \texttt{'$\sim$'} $\langle unit_{4} \rangle$ |
$\langle prefixOps_{1} \rangle$ | $\langle prefixOps_{2} \rangle$ \\
$\langle unit_{5} \rangle$ \= $::=$ \texttt{'('} $\langle typeterm \rangle$ \texttt{')'} | $\langle var \rangle$ | 
$\langle prefixOps_{0} \rangle$

\end{tabbing}

Consideramos a $\langle prefixOps_{i} \rangle$, con $0 \leq i \leq 2$, como las gramáticas de los operadores prefijos definidos por el usuario.
Mientras que $\langle infixOps \rangle$ es la gramática de los operadores binarios infijos, el cual debe hacer referencia a $\langle unit_{4} \rangle$.

Precedencia de los operadores:
\setlist[enumerate,1]{start=0}
\begin{enumerate}
  \item \textit{Prefix ops.}
  \item $\sim$
  \item \textit{Infix binary ops.}
  \item $\wedge$
  \item $\vee$
  \item $\rightarrow$
  \item $\leftrightarrow$
  \item $forall$ (operador infijo)
\end{enumerate}

Los operadores con un valor de precedencia (\textit{pv}) alto tienen menos precedencia que otro con un valor más bajo.
Por ejemplo, $\wedge$ tiene más precedencia que $\vee$, pues $pv (\wedge) < pv (\vee)$.

\textit{Prefix ops.} es el conjunto de los todos los operadores prefijos definidos por el usuario. Consideramos
que todos ellos tienen la misma precedencia.
Mientras que \textit{Infix binary ops.} es el conjunto de los operadores infijos (binarios) declarados por el usuario.
Cada operador infijo que da el usuario, tiene asociado un valor de precedencia (el 2) y un valor de precedencia infija (\textit{ipv}).
Un nuevo operador infijo tiene un \textit{ipv} más alto que los operadores previamente declarados.
Es decir que, cada operador infijo tiene menos precedencia que aquellos que fueron declarados previamente.
Solo los operadores binarios infijos dados por el usuario mantienen un \textit{ipv}.

Consideramos que todos los operadores binarios infijos asocian a derecha.



\section{Observaciones}
\begin{itemize}
  \item El comando \texttt{apply} puede actuar como el comando \texttt{assumption}.

  \item La substitución que encuentra el algoritmo de unificación es un termino cerrado.
  
  \item Cuando se ingresa un tipo mediante el comando \texttt{Theorem}, posiblemente se lo renombre, de modo tal de que éste respete la siguiente
  convención.
  
  \textbf{Convención 1}: Sea \textit{t} un tipo. 
  En \textit{t}, no se declaran dos variables de tipo ligadas con el mismo nombre, una más anidada que la otra.
  Además, $BV (t) \cap (\Gamma_{t} \cup Props) = \emptyset$. Donde, $\Gamma_{t}$ es el conjunto de variables de tipo del contexto, y $Props$ es el conjunto
  de variables de tipos libres.
  
  La \textbf{Convención 1} se aplica al tipo del \textit{goal}.
  
  \item La \textbf{Convención 1} nos permite evitar la captura de variables, a la hora de realizar la sustitución generada por el comando \texttt{unfold},
  y que en el entorno de variables de tipos no se ingrese la misma variable más de dos veces (cuando se aplica \texttt{intro}).
 
  \item Cuando implementamos el comando \texttt{unfold}, nos aseguramos que el tipo resultado de la sustitución, respete la \textbf{Convención 1}.
  
  \item Al implementar el comando \texttt{intro} sobre un ``para todo'', no es necesario chequear que no la variable de tipo ligada no se encuentre
  en el contexto de tipos, pues ya sabemos que no está allí, gracias al renombramiento de variables de tipos ligadas.
  
  \item Construimos un lambda término $t$, tal que $t:\alpha$, donde $\alpha$ es el tipo (asociado a una fórmula lógica), dado por el usuario. El isomorfismo
  de Curry-Howard, nos permite relacionar a los tipos con fórmulas lógicas, y a las pruebas con lambda términos.
  El lambda término $t$, se construye a partir de la prueba que da el usuario.
  El teorema de Curry-Howard, nos asegura que, si $t:\alpha$, entonces la fórmula asociada a $\alpha$ es válida.
  
  \item La función \texttt{habitar} se encarga de construir el lambda término asociado a la prueba que va dando el usuario.
  A cada regla de la deducción natural del sistema IFC, le corresponde una regla de tipo, en el lambda cálculo simplemente
  tipado. ¿Como construimos el término $t$, asociado a una prueba lógica?.
  A cada aplicación de una regla de tipo, le corresponde un lambda término ``vació''.
  Es decir, si se busca un lambda término de tipo $\beta \rightarrow \gamma$, por ejemplo, y se lo quiere construir mediante la regla 
  de tipo \textbf{T-Abs}, entonces, tenemos el término vació, $t_{1} = \lambda x:\beta. \; ?$, donde $? : \gamma$.
  Representamos a los términos vacíos, mediante funciones, en el caso anterior, tendríamos la función:

  \begin{verse}
  $t_{1}$ :: \texttt{Term} $\rightarrow$  \texttt{Term} \\
  $t_{1}$ $t$ = $\lambda x:\beta. \; t$
  \end{verse}

  Donde, \texttt{Term} es el tipo de los lambda términos. El argumento que se le pase a $t_{1}$, debería tener tipo $\gamma$.
  Esto se chequea de acuerdo a qué regla de tipo quiere aplicar el usuario.
  Por lo tanto, $t = (t_{1} . t_{2} \dots t_{n-2} . t_{n-1}) \; t_{n}$, donde $t_{n}$ es un lambda término no vació, que sirve de argumento a la composiciones
  de funciones. Cada $t_{i}$, con $i \in \{ 1 \dots n \}$, se corresponde con una regla de tipado, que a su vez se corresponde con una regla de deducción natural, 
  que da el usuario.
  
  \item Una subprueba se corresponde a un nodo en el árbol de derivación de la fórmula. Las tácticas que ingresa el usuario construyen dicho árbol,
  así se obtiene el lambda término que lo representa. La demostración de una fórmula puede requerir la prueba de otras fórmulas. Por ejemplo,
  en la demostración $\vdash (p \rightarrow p) \wedge (q \rightarrow q)$, al aplicar la introducción del and, se genera dos nuevas subpruebas.
  
  \begin{prooftree}
  \[
  \[
  p
  \using
  {ass}
  \justifies
  p
  \]
  \using
  {i_{\rightarrow}}
  \justifies
  p \rightarrow p
  \]
  \[
  \[
  q
  \using
  {ass}
  \justifies
  q
  \]
  \using
  {i_{\rightarrow}}
  \justifies
  q \rightarrow q
  \]
  \using
  {i_{\wedge}}
  \justifies
  (p \rightarrow p) \wedge (q \rightarrow q)
  \end{prooftree}
  
  En el asistente tendríamos lo siguiente:
  
  \begin{verbatim}
  > Theorem t1: (p -> p) /\ (q -> q).
  Hay 1 sub pruebas.

  p : Prop
  q : Prop
  ___________________[1/1]
  (p -> p) /\ (q -> q)
  > split.
  Hay 2 sub pruebas.

  p : Prop
  q : Prop
  ___________________[1/2]
  p -> p
  ___________________[2/2]
  q -> q
  \end{verbatim}
  
  Cuando se demuestra una fórmula, decimos que la subprueba termina.

  Podemos ver en la Figura \ref{Estados}, la aplicación del algoritmo de control de las subpruebas, al resolver el teorema:
  $p, q \vee  (p \rightarrow t) \rightarrow  r, t, p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w \vdash w$.
  En dicho diagrama consideramos a $C = H0 : p, H1 : q \vee  (p \rightarrow t) \rightarrow  r, H2 : t, H3: p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w$.
  Empleamos la siguiente notación:
  
  \tikz \node[rectangle,draw,label=below:
  Estado de $subps$]{Conjunto de pruebas};
  
  Donde la transición de un estado a otro se realiza a partir de un comando.

  \begin{figure}  
  \begin{tikzpicture}[->, node distance=2cm, auto, thick,main node/.style={rectangle,draw}]

  \node[main node, label={[align=left]below:$subps = [s_{0}]$\\$\wedge \; ty \; s_{0} = [w]$}] (1) {$C \vdash  w$};
  \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\ $\wedge \; ty \; s_{1} = [p \wedge q]$ \\ $\wedge \; ty \; s_{0} = [r,t]$}] 
  (2) [right=of 1] {$C \vdash  p \wedge t$, $C \vdash r$, $C \vdash q \vee t$};
  \begin{scope}[node distance=1.4cm]
  \node[main node, label={[align=left]below:$subps = [s_{2},s_{1},s_{0}]$\\$\wedge \; ty \; s_{2} = [p]$
  \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}]
  (3) [right=of 2] {$C \vdash  p , C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \begin{scope}[node distance=1cm]
  \coordinate [right=of 3] (4) {};
  \end{scope}
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}] 
  (5) [below=of 4] {$C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \begin{scope}[node distance=2.3cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [r]$ \\ $\wedge \; ty \; s_{0} = [q \vee t]$}] 
  (6) [left=of 5] {$C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [q \vee  (p \rightarrow t)]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (7) [left=of 6] {$C \vdash q \vee  (p \rightarrow t)$, $C \vdash t$};
  \coordinate [left=of 7] (8) {};
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [p \rightarrow t]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (9) [below=of 8] {$C \vdash p \rightarrow t$, $C \vdash t$};
  \end{scope}
  \begin{scope}[node distance=1.5cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [t]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (10) [right=of 9] {$\{C, H4: p \}\vdash t$, $C \vdash t$};
  \end{scope}
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{0}]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (11) [right=of 10] {$C \vdash t$};
  \node[main node, label={[align=left]below:$subps = [\;]$}] 
  (12) [right=of 11] {$\emptyset$};
  \end{scope}
  \path[draw] (1) edge [above] node {\texttt{apply H0}} (2) (2) edge [above] node {\texttt{split}} (3)
  (3) -- (4) (4) edge node [left] {\texttt{assumption}} (5) (5) edge node [above] {\texttt{assumption}} (6) 
  (6) edge node [above] {\texttt{apply H1}} (7) (7) -- (8) (8) -- node [right] {\texttt{right}} (9)
  (9) edge node [above] {\texttt{intro}} (10) (10) edge node [above] {\texttt{assumption}} (11)
  (11) edge node [above] {\texttt{assumption}} (12);
  \end{tikzpicture}
  \caption{Diagrama de estados.} \label{Estados}
  \end{figure}
  
  
  \item Aunque halla un lambda término con variables de tipo que tengan el mismo nombre que las variables de términos, su semántica de tipos está
  bien determinada.
  
  \item Al hacer el parser del lambda cálculo, asumí que la aplicación de tipos tiene más precedencia que la aplicación de términos, ¿está bien?.
  Ejemplo: $x \; y \; [A] = x \; (y \; [A]).$
  
  \item El pretty printer de los tipos o fórmulas, no utiliza la menor cantidad de paréntesis, cuando hay un \texttt{para todo} y \texttt{<->}.
  Por ejemplo \texttt{forall x, x <-> forall y, y}; se imprime así: \texttt{forall x, x <-> (forall y, y)}.
  
  \item Coq permite iniciar una nueva prueba de un teorema cuando la actual prueba no ha concluido.
  Sin embargo, solo se puede ``usar'' un teorema cuando ha sido probado mediante \textit{Proof}, y \textit{Qed}.
  
  \item Coq en algunos casos nos devuelve, mediante el comando \texttt{Print}, un lambda término ``incompleto'', al cual no es posible encontrarle
  un tipo mediante el comando \texttt{Check}. Ver \textit{Theorem k12}, en \texttt{plantilla\_p2.v}.
  
  \item En la implementación de la regla de tipado, correspondiente a la introducción del existe, consideramos que $t_{2}$ debe tener un tipo equivalente
  a $T_{2}[X:=U]$, llamemos lo $T$. Es decir que $T$ puede variar de $T_{2}[X:=U]$, con respecto a los nombres de las variables de tipo ligadas que aparecen en 
  el segundo.
  Hacemos esto para respetar la \textbf{Convención 1}. 
  
  El tipo $T$ lo calcula la función \texttt{applyTypes}. Para ello, realiza la sustitución $T_{2}[X:=U]$, más un renombramiento que respete la \textbf{Convención 1}.
  Ver Ejemplo 7, en los casos de inferencia OK.
  
%   \item El comando \texttt{exact} puede recibir un tipo cuando la unificación no puede precisar
%   una instancia de tipo.
%   Decidimos utilizar la palabra reservada $type$, para identificar que \texttt{exact} toma un tipo.
%   Si no hiciésemos esto, en ciertos casos no podríamos determinar si lo que recibe \texttt{exact} es un
%   tipo o un lambda término.
  
  \item Permitimos definir un teorema cuyo nombre sea el nombre de una hipótesis del contexto de
  su prueba. De todas formas, esto no sería un problema.
  
  \item Consideramos dos espacios de nombres para las variables.
  \begin{itemize}
    \item $v.términos = v.ligadas_{te} \cup v.libres_{te}$
    \item $v.libres_{te} = teoremas$
    \item $v.tipos = v.ligadas_{ti} \cup v.libres_{ti}$
    \item $v.libres_{ti} = proposiciones \cup operadores$
  \end{itemize}
  
  Donde, $v.ligadas_{ti} \cap v.libres_{ti} = \emptyset$, para satisfacer la \textbf{Convención 1}.
  Además, $v.libres_{te} \cap v.libres_{ti} = \emptyset$, para desambiguar las aplicaciones de variables.
  
  También, consideramos para cada prueba, $hipótesis \cap teoremas = \emptyset$. De lo contrario, tendríamos conflictos de nombres.
  
  \item Cuando se incluye un tipo en un lambda término mediante el constructor $as$, se puede producir un error de parseo, si no se lo
  incluye entre paréntesis. Por ejemplo, aplicaciones de variables de lambda términos documentadas mediante $as$, pueden entenderse
  como un tipo. Ejemplo: $\lambda a.\lambda x:a. \lambda y:a \rightarrow a. y \; as \; a \rightarrow a \; x \; as \; a$,
  es incorrecto. Lo correcto es: $\lambda a.\lambda x:a. \lambda y:a \rightarrow a. y \; as \; (a \rightarrow a) \; x \; as \; a$
  
  \item No renombramos el tipo asociado al \textit{as} de un lambda término, pues no es necesario.
  

\end{itemize}

\section{Lo que falta}
\begin{itemize}
%   \item Hacer el comando \texttt{infer} completo. Es decir, que funcione cuando en el lambda término aparecen operaciones foldeables.
%   Ver \texttt{Theorem t34}, \texttt{Theorem t35}, en \texttt{casos.txt}.
%   
  \item Añadir constantes (creo que serían axiomas).
  
  \item Simplificar código.
\end{itemize}




\end{document}
