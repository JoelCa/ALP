\documentclass[a4paper,11pt]{article}
\usepackage[left=1.5cm,top=2.0cm,right=1.5cm,bottom=2.0cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{prooftree}
\usetikzlibrary{positioning, babel,shapes}
\newdimen\nodeDist
\nodeDist=35mm

\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{}
\author{}

\begin{document}

\maketitle

\begin{center}
\section*{Análisis de lenguajes de programación} 
\end{center}

\newpage{\pagestyle{empty}\cleardoublepage}

\section{Data types}

\begin{verbatim}
data ProverState = PSt { proof :: Maybe ProofState
                       , global :: ProverGlobal
                       }
\end{verbatim}

Estado general del asistente.
\begin{itemize}
  \item \texttt{proof}: representa a la prueba que construye el usuario, si existe.
  \item \texttt{global}: datos globales.
\end{itemize}

\begin{verbatim}
data ProverGlobal = PGlobal { fTypeContext :: FTypeContext
                            , teorems :: Teorems
                            , opers :: FOperations
                            }
\end{verbatim}

Este registro contiene los datos globales del asistente.
\begin{itemize}
  \item \texttt{fTypeContext}: variables de tipo libres.
  \item \texttt{teorems}: teoremas ya probados.
  \item \texttt{opers}: representa a las operaciones que pueden desplegarse.
\end{itemize}

\begin{verbatim}
data ProofState = PState { name :: String
                         , types :: (Type,TType)
                         , constr :: ProofConstruction
                         }
\end{verbatim}

Estado general de la prueba que realiza el usuario.
\begin{itemize}
  \item \texttt{name}: nombre de la prueba.
  \item \texttt{types}: tipo, con y sin nombres, que se quiere habitar. Se corresponde a fórmula que quiere probar el usuario.
  \item \texttt{constr}: construcción de la prueba.
\end{itemize}

\begin{verbatim}
data ProofConstruction = PConstruction { tsubp :: Int
                                       , subps :: [SubProof]
                                       , cglobal :: ProverGlobal
                                       , term :: [SpecialTerm]
                                       }
\end{verbatim}

Prueba que realiza el usuario.
\begin{itemize}
  \item \texttt{tsubp}: cantidad total de subpruebas activas.
  \item \texttt{subps}: mantiene a todas las subpruebas activas.
  \item \texttt{cglobal}: datos globales vigentes durante la construcción de la prueba.
  \item \texttt{term}: representa al lambda término que va formando el usuario.
\end{itemize}

\begin{verbatim}
data SubProof = SP { termContext :: TermContext
                   , bTypeContext :: BTypeContext
                   , lsubp :: Int
                   , tvars :: Int
                   , ty :: [Maybe (Type, TType)]
                   }
\end{verbatim}

Representa a un conjunto de subpruebas.
Consideramos que todas ellas tienen el mismo contexto, comparten tanto los campos \texttt{termContext} como \texttt{bTypeContext}.
\begin{itemize}
  \item \texttt{termContext}: contexto de las variables de término.
  \item \texttt{bTypeContext}: contexto de las variables de tipo ligadas. Nos referimos a las variables que corresponden a una cuantificación.
  \item \texttt{lsubp}: indica la cantidad de subpruebas que contiene.
  \item \texttt{tvars}: cantidad total de variables de tipo ligadas, y variables de términos.
  \item \texttt{ty}: tipos objetivos de cada subprueba.
\end{itemize}

A continuación, explicamos el data type utilizado para representar al lambda término que construye el usuario.

\begin{verbatim}
data SpecialTerm = HoleT (Term->Term) | DoubleHoleT (Term->Term->Term) |
                   Term Term | TypeH TypeHole

data TypeHole = HTe ((Type, TType) -> Term) | HTy ((Type, TType) -> TypeHole)
\end{verbatim}

El data type \texttt{SpecialTerm} representa a un lamba término que puede tener dos tipos de agujero: lambda términos o tipos, de manera
exclusiva, es decir solo puede tener un solo tipo de agujero.

El data type \texttt{TypeHole} representa agujeros de tipos en un lambda término.


\section{Observaciones}
\begin{itemize}
  \item El comando \texttt{apply} puede actuar como el comando \texttt{assumption}.
  \item Cuando aplicamos el comando \texttt{intro} sobre un goal con ``para todo'', las variables
  ligadas al/los para todo/s, pasan a ser libres en el nuevo goal. 
  \item La substitución que encuentra el algoritmo de unificación es un termino cerrado.
  \item Sean $\Gamma_{t}$ el contexto de tipos inicial, y $\alpha$ un tipo dado por el usuario. Luego, $FV(\alpha) \subseteq \Gamma_{t}$.
  Además, si $FV(\alpha) \cap BV(\alpha) \neq  \emptyset$, se encuentra mediante substituciones de variables de tipos ligadas, un tipo $\alpha'$ 
  equivalente a $\alpha$, tal que $FV(\alpha') \cap BV(\alpha') = \emptyset$, y $FV(\alpha') = FV(\alpha)$.
  
  El contexto de tipos inicial, se define a partir del comando \texttt{Props}.
  
  \item Al implementar el comando \texttt{intro} sobre un ``para todo'', no es necesario chequear que no la variable de tipo ligada no se encuentre
  en el contexto de tipos, pues ya sabemos que no está allí, gracias al renombramiento de variables de tipos ligadas.
  
  \item Construimos un lambda término $t$, tal que $t:\alpha$, donde $\alpha$ es el tipo (asociado a una fórmula lógica), dado por el usuario. El isomorfismo
  de Curry-Howard, nos permite relacionar a los tipos con fórmulas lógicas, y a las pruebas con lambda términos.
  El lambda término $t$, se construye a partir de la prueba que da el usuario.
  El teorema de Curry-Howard, nos asegura que, si $t:\alpha$, entonces la fórmula asociada a $\alpha$ es válida.
  
  \item La función \texttt{habitar} se encarga de construir el lambda término asociado a la prueba que va dando el usuario.
  A cada regla de la deducción natural del sistema IFC, le corresponde una regla de tipo, en el lambda cálculo simplemente
  tipado. ¿Como construimos el término $t$, asociado a una prueba lógica?.
  A cada aplicación de una regla de tipo, le corresponde un lambda término ``vació''.
  Es decir, si se busca un lambda término de tipo $\beta \rightarrow \gamma$, por ejemplo, y se lo quiere construir mediante la regla 
  de tipo \textbf{T-Abs}, entonces, tenemos el término vació, $t_{1} = \lambda x:\beta. \; ?$, donde $? : \gamma$.
  Representamos a los términos vacíos, mediante funciones, en el caso anterior, tendríamos la función:

  \begin{verse}
  $t_{1}$ :: \texttt{Term} $\rightarrow$  \texttt{Term} \\
  $t_{1}$ $t$ = $\lambda x:\beta. \; t$
  \end{verse}

  Donde, \texttt{Term} es el tipo de los lambda términos. El argumento que se le pase a $t_{1}$, debería tener tipo $\gamma$.
  Esto se chequea de acuerdo a qué regla de tipo quiere aplicar el usuario.
  Por lo tanto, $t = (t_{1} . t_{2} \dots t_{n-2} . t_{n-1}) \; t_{n}$, donde $t_{n}$ es un lambda término no vació, que sirve de argumento a la composiciones
  de funciones. Cada $t_{i}$, con $i \in \{ 1 \dots n \}$, se corresponde con una regla de tipado, que a su vez se corresponde con una regla de deducción natural, 
  que da el usuario.
  
  \item Utilizamos el siguiente AST para representar a un lambda término:
  \begin{verbatim}
  data Term  = Bound Int
             | Free Name 
             | Term :@: Term
             | Lam (Type,TType) Term
             | BLam Var Term
             | Term :!: (Type,TType)
  \end{verbatim}
  
  Donde, \texttt{Type} es el AST de los tipos, y \texttt{TType} es el AST de los tipos sin nombres, es decir que estos emplean la notación De Bruijn.
  \texttt{Type} nos es útil a la hora de imprimir en pantalla el tipo del lambda término, de modo tal que tenga el tipo ingresado por el usuario.
  Mientras que, \texttt{TType} lo usamos en todas las operatorias sobre los tipos de los lambda términos, por ejemplo, en la unificación de tipos, que
  se realiza cuando se aplica la regla de eliminación del \textbf{para todo}.
  
  Si solo emplearíamos \texttt{TType}, el tipo de lambda término no coincidiría con el tipo dado por el usuario.
  
  \item Cuando el tipo $\alpha$ no contiene \textbf{para todos} ni \textbf{existes}, la representación de $\alpha$ mediante el AST \texttt{Type} es 
  prácticamente la misma que \texttt{TType}, solo varían en el nombre de los constructores.
  
  \item Una subprueba se corresponde a un nodo en el árbol de derivación de la fórmula. Las tácticas que ingresa el usuario construyen dicho árbol,
  así se obtiene el lambda término que lo representa. La demostración de una fórmula puede requerir la prueba de otras fórmulas. Por ejemplo,
  en la demostración $\vdash (p \rightarrow p) \wedge (q \rightarrow q)$, al aplicar la introducción del and, se genera dos nuevas subpruebas.
  
  \begin{prooftree}
  \[
  \[
  p
  \using
  {ass}
  \justifies
  p
  \]
  \using
  {i_{\rightarrow}}
  \justifies
  p \rightarrow p
  \]
  \[
  \[
  q
  \using
  {ass}
  \justifies
  q
  \]
  \using
  {i_{\rightarrow}}
  \justifies
  q \rightarrow q
  \]
  \using
  {i_{\wedge}}
  \justifies
  (p \rightarrow p) \wedge (q \rightarrow q)
  \end{prooftree}
  
  En el asistente tendríamos lo siguiente:
  
  \begin{verbatim}
  > Theorem t1: (p -> p) /\ (q -> q).
  Hay 1 sub pruebas.

  p : Prop
  q : Prop
  ___________________[1/1]
  (p -> p) /\ (q -> q)
  > split.
  Hay 2 sub pruebas.

  p : Prop
  q : Prop
  ___________________[1/2]
  p -> p
  ___________________[2/2]
  q -> q
  \end{verbatim}
  
  Cuando se demuestra una fórmula, decimos que la subprueba termina.

  Podemos ver en la Figura \ref{Estados}, la aplicación del algoritmo de control de las subpruebas, al resolver el teorema:
  $p, q \vee  (p \rightarrow t) \rightarrow  r, t, p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w \vdash w$.
  En dicho diagrama consideramos a $C = H0 : p, H1 : q \vee  (p \rightarrow t) \rightarrow  r, H2 : t, H3: p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w$.
  Empleamos la siguiente notación:
  
  \tikz \node[rectangle,draw,label=below:
  Estado de $subps$]{Conjunto de pruebas};
  
  Donde la transición de un estado a otro se realiza a partir de un comando.

  \begin{figure}  
  \begin{tikzpicture}[->, node distance=2cm, auto, thick,main node/.style={rectangle,draw}]

  \node[main node, label={[align=left]below:$subps = [s_{0}]$\\$\wedge \; ty \; s_{0} = [w]$}] (1) {$C \vdash  w$};
  \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\ $\wedge \; ty \; s_{1} = [p \wedge q]$ \\ $\wedge \; ty \; s_{0} = [r,t]$}] 
  (2) [right=of 1] {$C \vdash  p \wedge t$, $C \vdash r$, $C \vdash q \vee t$};
  \begin{scope}[node distance=1.4cm]
  \node[main node, label={[align=left]below:$subps = [s_{2},s_{1},s_{0}]$\\$\wedge \; ty \; s_{2} = [p]$
  \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}]
  (3) [right=of 2] {$C \vdash  p , C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \begin{scope}[node distance=1cm]
  \coordinate [right=of 3] (4) {};
  \end{scope}
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}] 
  (5) [below=of 4] {$C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \begin{scope}[node distance=2.3cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [r]$ \\ $\wedge \; ty \; s_{0} = [q \vee t]$}] 
  (6) [left=of 5] {$C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [q \vee  (p \rightarrow t)]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (7) [left=of 6] {$C \vdash q \vee  (p \rightarrow t)$, $C \vdash t$};
  \coordinate [left=of 7] (8) {};
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [p \rightarrow t]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (9) [below=of 8] {$C \vdash p \rightarrow t$, $C \vdash t$};
  \end{scope}
  \begin{scope}[node distance=1.5cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [t]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (10) [right=of 9] {$\{C, H4: p \}\vdash t$, $C \vdash t$};
  \end{scope}
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{0}]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (11) [right=of 10] {$C \vdash t$};
  \node[main node, label={[align=left]below:$subps = [\;]$}] 
  (12) [right=of 11] {$\emptyset$};
  \end{scope}
  \path[draw] (1) edge [above] node {\texttt{apply H0}} (2) (2) edge [above] node {\texttt{split}} (3)
  (3) -- (4) (4) edge node [left] {\texttt{assumption}} (5) (5) edge node [above] {\texttt{assumption}} (6) 
  (6) edge node [above] {\texttt{apply H1}} (7) (7) -- (8) (8) -- node [right] {\texttt{right}} (9)
  (9) edge node [above] {\texttt{intro}} (10) (10) edge node [above] {\texttt{assumption}} (11)
  (11) edge node [above] {\texttt{assumption}} (12);
  \end{tikzpicture}
  \caption{Diagrama de estados.} \label{Estados}
  \end{figure}
  
  
  \item Aunque halla un lambda término con variables de tipo que tengan el mismo nombre que las variables de términos, su semántica de tipos está
  bien determinada.
  
  \item Al hacer el parser del lambda cálculo, asumí que la aplicación de tipos tiene más precedencia que la aplicación de términos, ¿está bien?.
  Ejemplo: $x \; y \; [A] = x \; (y \; [A]).$
  

\end{itemize}

\section{Lo que falta}
\begin{itemize}
  \item Arreglar el parser, respecto a los operadores que define el usuario (precedencia y demás).
  Ver caso: \texttt{Definition x x y := forall w, forall v, x and y}.
  \item Hacer que el lambda término devuelto en la construcción de una prueba, puede ser inferido por el comando \texttt{infer}.
  Ver caso: \texttt{Theorem: p -> q -> (((p and q) and (p and p)) and q) and p}.
  \item Simplicar el data type \texttt{SubProof}.
\end{itemize}












\end{document}
