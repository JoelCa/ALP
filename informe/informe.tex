\documentclass[a4paper,11pt]{article}
\usepackage[left=1.5cm,top=2.0cm,right=1.5cm,bottom=2.0cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern,bm}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{bussproofs}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage{amsthm}

\newtheorem{theorem}{Teorema}
\theoremstyle{definition}
\newtheorem{definition}{Definición}

\usetikzlibrary{positioning, babel,shapes}
\newdimen\nodeDist
\nodeDist=35mm

\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{}
\author{}

\begin{document}

\maketitle 

\begin{center}
\section*{Análisis de lenguajes de programación} 
\subsection*{Asistente de prueba de la lógica proposicional constructiva de segundo orden}
\end{center}

\newpage{\pagestyle{empty}\cleardoublepage}


\section{Motivación}
Era de especial intereses para el autor entender la cual es la relación entre la lógica y el lambda cálculo.
Para ello decide implementar un asistente de prueba, el cual emplea la correspondencia
existente entre el Sistema F, y la lógica proposicional constructiva de segundo orden.
 
\section{Fórmulas como tipos}
Podemos interpretar $M : \sigma$ de dos formas:
\begin{itemize}
  \item Término como programa, tipo como especificación: $M$ es una función de tipo $\sigma$.
  \item Tipo como una fórmula, término como su prueba: $M$ es una prueba de la fórmula $\sigma$.
\end{itemize}

La correspondencia Curry-Howard fórmulas como tipos, es una correspondencia uno a uno entre términos
tipados del lambda cálculo y las derivaciones en la lógica proposicional minimal.
Desde el punto de vista de la lógica: $x_{1}:\tau_{1}, x_{2}:\tau_{2}, \ldots, x_{n}:\tau_{n} \vdash M : \sigma$,
puede leerse como $M$ es una prueba de $\sigma$ a partir de las hipótesis $\tau_{1}, \tau_{2}, \ldots, \tau_{n}$.  
 


\begin{definition}
El sistema de lógica proposicional PROP restringido al conectivo de implicación se define de la siguiente manera.

\begin{itemize}
  \item Sintaxis abstracta:
  
  $prop ::= PropVar \; | \; (prop \rightarrow prop)$.
  
  \item Reglas de derivación. Donde $\Delta$ es un conjunto de proposiciones, $\sigma$ y $\tau$ son proposiciones.
    
    \begin{minipage}[t]{0.3\linewidth}
      \centering
      \begin{prooftree}
        \AxiomC{$\sigma \in \Delta$}
        \UnaryInfC{$\Delta \vdash \sigma$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      \centering

      \begin{prooftree}
        \AxiomC{$\sigma \rightarrow \tau \hspace{0.5cm} \sigma$}
        \RightLabel{\scriptsize \textsc{E-$\rightarrow$}}
        \UnaryInfC{$\tau$}
      \end{prooftree}
      
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      \centering
      \begin{prooftree}
        \AxiomC{ $[\sigma]^{j}$}
        \noLine
        \UnaryInfC{$\vdots$}
        \noLine
        \UnaryInfC{$\tau$}        
        \RightLabel{\scriptsize \textsc{I-$\rightarrow^{[j]}$}}
        \UnaryInfC{$\sigma \rightarrow \tau$}
      \end{prooftree}
      
    \end{minipage}
   
\end{itemize}

Decimos que $\Delta \vdash_{Prop} \sigma$ si existe una derivación usando las reglas, con conclusión $\sigma$ y hipótesis en $\Delta$.
\end{definition}

Procedemos a definir lo que entendemos por fórmulas como tipos. Para ello consideramos al contexto en PROP como listas
($\Delta$ es una lista en la siguiente definición).


\begin{definition}
  La noción de prueba como término, es decir, derivaciones de PROP a términos del lambda cálculo simplemente tipado $\lambda_{\rightarrow}$, 
  se define inductivamente como sigue.

  Asociamos a las listas de proposiciones $\Delta$ un contexto $\Gamma$, en donde se reemplaza $\sigma$ en $\Delta$ con $x_{i} : \sigma_{i} \in \Gamma$.
  Del lado izquierdo vemos la clausula inductiva de la derivación y en el lado derecho, se describe del lado superior a la línea,
  los términos que tenemos por inducción, y debajo, el término asociado a la derivación.

  \vspace{0.5cm}

  \begin{minipage}[t]{0.4\linewidth}
    \centering

    \begin{prooftree}
      \AxiomC{$\sigma \in \Delta$}
      \UnaryInfC{$\Delta \vdash \sigma$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\sigma \rightarrow \tau \hspace{0.5cm} \sigma$}
      \UnaryInfC{$\tau$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC { $[\sigma]^{j}$}
      \noLine
      \UnaryInfC{$\vdots$}
      \noLine
      \UnaryInfC{$\tau$}        
      \UnaryInfC{$\sigma \rightarrow \tau$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}
    \centering

    \begin{prooftree}  
      \AxiomC{$x : \sigma \in \Delta$}
      \UnaryInfC{$\Gamma \vdash x : \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma_{1} \vdash M : \sigma \rightarrow \tau$}
      \AxiomC{$\Gamma_{2} \vdash N : \sigma$}
      \BinaryInfC{$\Gamma_{1} \cup \Gamma_{2} \vdash M \; N : \tau$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma,x:\sigma \vdash M : \tau$}
      \UnaryInfC{$\Gamma \vdash \lambda x : \sigma. \; M : \sigma \rightarrow \tau$}
    \end{prooftree}

  \end{minipage}

  \vspace{0.5cm}

  Si $\mathcal{D}$ es una derivación en PROP, entonces $\overline{\mathcal{D}}$ es un lambda término en $\lambda_{\rightarrow}$.
\end{definition}


\begin{theorem}
  Soundness, Completitud de formulas como tipos.

  \begin{enumerate}
  \item Si $\mathcal{D}$ es una deducción natural en PROP con conclusión $\sigma$ y hipótesis en $\Delta$, entonces
    $\bm{x}:\bm{\Delta} \vdash \overline{\mathcal{D}} : \sigma$, en $\lambda_{\rightarrow}$.
  \item Si $\Gamma \vdash M : \sigma$ en $\lambda_{\rightarrow}$, entonces hay una derivación de $\sigma$ desde $\Delta$ en PROP,
    donde $\Delta$ es $\Gamma$ sin la asignación de variables.
  \end{enumerate}

\end{theorem}

La correspondencia fórmulas como tipos constituye un isomorfismo entre derivaciones en PROP y términos bien formados en $\lambda_{\rightarrow}$.
Dicho de otra manera, una fórmula es teorema si y solo si es un tipo habitado.

\subsection{Lambda cálculo con polimorfismo}
\label{Lambda cálculo con polimorfismo}

El lambda cálculo con polimorfismo (Sistema F) sirve como una notación de las pruebas de la lógica proposicional constructiva
de segundo orden.
Comenzamos definiendo al Sistema F.

\begin{definition}
  Los tipos del Sistema F, estilo Church, son:

  $Typ := TVar \; | \; (Typ \rightarrow Typ) \; | \; \forall \alpha . Typ$

  Mientras que las reglas de derivación son :

  \begin{minipage}[t]{0.4\linewidth}
    \centering

    \begin{prooftree}  
      \AxiomC{$x : \sigma \in \Gamma$}
      \UnaryInfC{$\Gamma \vdash x : \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma_{1} \vdash M : \sigma \rightarrow \tau$}
      \AxiomC{$\Gamma_{2} \vdash N : \sigma$}
      \BinaryInfC{$\Gamma_{1} \cup \Gamma_{2} \vdash M \; N : \tau$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma,x:\sigma \vdash M : \tau$}
      \UnaryInfC{$\Gamma \vdash \lambda x : \sigma. \; M : \sigma \rightarrow \tau$}
    \end{prooftree}

  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}

    \begin{prooftree}  
      \AxiomC{$\Gamma \vdash M : \sigma$}
      \RightLabel{$\alpha \notin FV(\Gamma)$}
      \UnaryInfC{$\Gamma \vdash \lambda \alpha. M : \forall \alpha. \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma \vdash M : \forall \alpha. \sigma$}
      \UnaryInfC{$\Gamma \vdash : \sigma [ \alpha := \tau]$}
    \end{prooftree}
    
  \end{minipage}
\end{definition}

\begin{figure}
  \centering
  \begin{minipage}[t]{0.35\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Términos: \\
        t \hspace{-0.1cm} ::= x \\ 
        \> $\mathtt {\lambda x : T. \; t}$ \\
        \> t t \\
        \> $\lambda$X. t \\
        \> t [T] \\
        \> \{$^{*}$T, t\} as T \\
        \> let \{X, x\} = t in t \\
        \> t as T
      \end{tabbing} 
    }
  \end{minipage}
  \begin{minipage}[t]{0.3\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Contexto: \\
        $\Gamma$ \hspace{-0.1cm} ::= $\emptyset$ \\
        \> $\Gamma$, x:T \\ 
        \> $\Gamma$, X
      \end{tabbing} 
    }
  \end{minipage}
  \begin{minipage}[t]{0.3\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Tipos: \\
        T \hspace{-0.1cm} ::= X \\
        \> T $\rightarrow$ T \\
        \> forall X, T \\
        \> exists X, T 
      \end{tabbing} 
    }
  \end{minipage}

  \texttt{Reglas de tipos}

  \begin{minipage}[t]{0.4\linewidth}
    \centering
    
    \begin{prooftree}  
      \AxiomC{$\mathtt{x : T \in \Gamma}$}
      \RightLabel{\scriptsize \textsc{T-Var}}
      \UnaryInfC{$\mathtt{\Gamma \vdash x : T}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : T_{11} \rightarrow T_{12} \quad \Gamma \vdash t_{2} : T_{11}}$}
      \RightLabel{\scriptsize \textsc{T-App}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} t_{2} : T_{12}}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma, x: T_{1} \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-Abs}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \lambda x: T_{1}. \; t_{2} : T_{1} \rightarrow T_{2}}$}
    \end{prooftree}
    
    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{2} : T_{2} [X \rightarrow U]}$}
      \RightLabel{\scriptsize \textsc{T-Pack}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \{^{*}U, t_{2}\} \; as \; exists \; X,\;  T_{2}}$}
      \noLine
      \UnaryInfC{$\mathtt{: exists \; X,\;  T_{2}}$}
    \end{prooftree}

  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}
    \centering  

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma, X \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-TAbs}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \lambda X. \; t_{2} : forall \; X, \; T_{2}}$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : forall \; X, \; T_{12}}$}
      \RightLabel{\scriptsize \textsc{T-TApp}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} \; [T_{2}] : T_{12} [X \rightarrow T_{2}]}$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : T}$}
      \RightLabel{\scriptsize \textsc{T-Ascribe}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} \; as \; T : T}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : exists \; X, \; T_{12} }$}
      \AxiomC{$\mathtt{\Gamma, X, x:T_{12}  \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-Unpack}}
      \BinaryInfC{$\mathtt{\Gamma \vdash let \{ X, x \} = t_{1} \; in \; t_{2} : T_{2}}$}
    \end{prooftree}
    
  \end{minipage}
  \caption{Sintaxis y reglas de tipos del Sistema F extendido.}
  \label{SintaxisTiposF}
\end{figure}

Implementamos el Sistema F siguiendo las reglas de inferencia de tipos que presenta Pierce \cite{pierce}.
Ver Figura \ref{SintaxisTiposF}.
Se decidió extenderlo con el inclusión del cuantificador existencial, y la adscripción de un tipo a término.
Era necesario mapear la introducción y eliminación del existencial con un lambda término o regla de inferencia de tipo, 
lo cual puede realizarse de manera directa con la inclusión del cuantificador al lenguaje. 

El sistema F, permite la abstracción tanto de términos como tipos. Con lo cual podemos ``definir'' nuevos
constructores de tipos, a partir del lenguaje, como se muestra a continuación.

\begin{definition}
  Definición de operadores de la lógica intuicionista.

  \begin{itemize}
  \item $\bot := \forall \alpha. \alpha$
  \item $\sigma \wedge \tau := \forall \alpha. (\sigma \rightarrow \tau \rightarrow \alpha) \rightarrow \alpha$
  \item $\sigma \vee \tau := \forall \alpha. (\sigma \rightarrow \alpha) \rightarrow (\tau \rightarrow \alpha) \rightarrow \alpha$
  \item $\neg \alpha := \alpha \rightarrow \bot$
  \item $\alpha \leftrightarrow \beta := (\alpha \rightarrow \beta) \wedge (\beta \rightarrow \alpha)$ 
  \end{itemize}
\end{definition}

A partir de la definición anterior es posible definir las reglas de introducción y eliminación
de los operadores $\bot, \wedge,$ y $\vee$.

Sabemos que es posible describir al existencial de la siguiente manera:
$\exists \alpha. \sigma := \forall \beta. (\forall \alpha. \sigma \rightarrow \beta) \rightarrow \beta$.

Sin embargo, creemos que no es posible dar su regla de introducción y eliminación mediante un lambda término.
Por ello, lo añadimos al lenguaje. Ver Figura \ref{SintaxisTiposF}.


\subsection{Construcción de pruebas}
\label{construcciónDePruebas}

El asistente de prueba, implementa un chequeo de tipos sobre el lambda término que se construye a
medida que el usuario realiza una prueba. 
Cuando la prueba finaliza el lambda término asociado a la prueba tendrá como tipo la fórmula probada.

Utilizamos  términos con agujeros, de modo tal que sucesivas aplicaciones de las tácticas terminen 
de armar el lambda término que cumpla con el tipo deseado.

Veamos como se construye el lambda término de acuerdo a la aplicación de las tácticas.

\begin{itemize}
\item \texttt{assumption}: corresponde a la prueba $H$.
  
  \AxiomC{$\Gamma$}
  \noLine
  \UnaryInfC{$H:\alpha$}
  \UnaryInfC{$? : \alpha$}
  \DisplayProof

\item \texttt{intro}: tenemos dos casos.

  \begin{itemize}
  \item corresponde a la prueba $\lambda H:\alpha. \; ?_{1}$.

    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \UnaryInfC{$? : \alpha \rightarrow \beta$}
      \DisplayProof    
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      $\rightsquigarrow$
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \alpha$}
      \UnaryInfC{$?_{1} : \beta$}
      \DisplayProof    
    \end{minipage}

  \item corresponde a la prueba $\lambda x. \; ?_{1}$.

    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \UnaryInfC{$? : \forall x. \; \beta$}
      \DisplayProof    
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      $\rightsquigarrow$
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$x$}
      \UnaryInfC{$?_{1} : \beta$}
      \DisplayProof    
    \end{minipage}
    
  \end{itemize}  

\item \texttt{apply H}: corresponde a la prueba $(H \; ?_{1})$.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H:\alpha \rightarrow \beta$}
    \UnaryInfC{$? : \beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \rightarrow \beta$}
    \UnaryInfC{$?_{1} : \alpha$}
    \DisplayProof    
  \end{minipage}

\item \texttt{cut $\beta$}: corresponde a la prueba $(?_{1} \; ?_{2})$.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$? : \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{1} : \beta \rightarrow \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{2} : \beta$}
    \DisplayProof    
  \end{minipage}

\item \texttt{apply H}: tenemos 3 casos.
  
  \begin{itemize}
  \item Corresponde a la prueba $(H \; [\theta_{1}] [\theta_{2}] .. [\theta_{n}])$
    de modo tal que, $\gamma = \beta \; [ x_{1} \rightarrow \theta_{1} ] .. [x_{n} \rightarrow \theta_{n}].$
    
    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \forall x_{1}. \forall x_{2}. .. \forall x_{n}. \; \beta$}
      \UnaryInfC{$? : \gamma$}
      \DisplayProof
    \end{minipage}
    
  \item Corresponde a la prueba $(H \; ?_{1} .. ?_{n})$.

    \begin{minipage}[t]{0.3\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \alpha_{1} \rightarrow \alpha_{2} \rightarrow ... \rightarrow \alpha_{n}$}
      \UnaryInfC{$? : \beta$}
      \DisplayProof
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      $\rightsquigarrow$
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : ..$}
      \UnaryInfC{$?_{1} : \alpha_{1}$}
      \DisplayProof    
    \end{minipage}
    \begin{minipage}[t]{0.05\linewidth}
      $\ldots$
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : ..$}
      \UnaryInfC{$?_{n} : \alpha_{n}$}
      \DisplayProof    
    \end{minipage}

  \item Corresponde a la prueba $H$.

    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H:\alpha$}
    \UnaryInfC{$? : \alpha$}
    \DisplayProof

  \end{itemize}

\item \texttt{left}: Corresponde a la prueba $(intro\_or1 \; [\alpha] \; [\beta] \; ?_{1})$.
  
  \begin{minipage}[t]{0.3\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$? : \alpha \vee \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{1} : \alpha$}
    \DisplayProof    
  \end{minipage}

\item \texttt{right}: Corresponde a la prueba $(intro\_or2 \; [\alpha] \; [\beta] \; ?_{1})$.
  
  \begin{minipage}[t]{0.3\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$? : \alpha \vee \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{1} : \beta$}
    \DisplayProof    
  \end{minipage}
  
\item \texttt{split}: Corresponde a la prueba $(intro\_and \; [\alpha] \; [\beta] \; ?_{1} \; ?_{2})$.

  \begin{minipage}[t]{0.3\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$? : \alpha \wedge \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{1} : \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{2} : \beta$}
    \DisplayProof    
  \end{minipage}

\item \texttt{absurd $\alpha$}: Corresponde a la prueba $(intro\_bottom \; [\alpha] \; ?_{1} \; ?_{2})$.

  \begin{minipage}[t]{0.3\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$? : False$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{1} : \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{2} : \neg \alpha$}
    \DisplayProof    
  \end{minipage}

\item \texttt{exists $\alpha$}: Corresponde a la prueba $\{ ^*\alpha, ?_1 \} \; as \; exists \; x, \; \sigma$. 

  \begin{minipage}[t]{0.3\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$? : exists \; x, \; \sigma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$?_{1} : \sigma [x \rightarrow \alpha]$}
    \DisplayProof    
  \end{minipage}


\item \texttt{elim H}: tenemos varios casos.

  \begin{itemize}
  \item Corresponde a la prueba $(elim\_or \; [\alpha] \; [\beta] \; [\sigma] \; H \; ?_{1} \; ?_{2})$.

    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \alpha \vee \beta$}
      \UnaryInfC{$? : \sigma$}
      \DisplayProof
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      $\rightsquigarrow$
    \end{minipage}
    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \alpha \vee \beta$}
      \UnaryInfC{$?_1 : \alpha \rightarrow \sigma$}
      \DisplayProof    
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \alpha \vee \beta$}
      \UnaryInfC{$?_2 : \beta \rightarrow \alpha$}
      \DisplayProof    
    \end{minipage}

  \item Corresponde a la prueba $(elim\_and \; [\alpha] \; [\beta] \; [\sigma] \; H \; ?_1)$.

    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \alpha \wedge \beta$}
      \UnaryInfC{$? : \sigma$}
      \DisplayProof
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      $\rightsquigarrow$
    \end{minipage}
    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : \alpha \wedge \beta$}
      \UnaryInfC{$?_1 : \alpha \rightarrow \beta \rightarrow \sigma$}
      \DisplayProof    
    \end{minipage}

  \item Corresponde a la prueba $(elim\_bottom \; [\sigma] \; H)$.

    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : False$}
      \UnaryInfC{$? : \sigma$}
      \DisplayProof
    \end{minipage}

  \item Corresponde a la prueba $let \; \{x, H'\} = H \; in \; ?_1$

    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$H : exists \; x, \; \alpha $}
      \UnaryInfC{$? : \sigma$}
      \DisplayProof
    \end{minipage}
    \begin{minipage}[t]{0.1\linewidth}
      $\rightsquigarrow$
    \end{minipage}
    \begin{minipage}[t]{0.2\linewidth}
      \AxiomC{$\Gamma$}
      \noLine
      \UnaryInfC{$x$}
      \noLine
      \UnaryInfC{$H' : \alpha$}
      \UnaryInfC{$?_1 : \sigma$}
      \DisplayProof    
    \end{minipage}

  \end{itemize}

\end{itemize}



\section{Data types}

\begin{verbatim}
data ProverState = PSt { proof :: Maybe ProofState
                       , global :: GlobalState
                       , tempSave :: (FilePath, Handle)
                       , input :: Input
                       , cc :: Int
                       }
\end{verbatim}

Estado general del asistente.
\begin{itemize}
  \item \texttt{proof}: representa a la prueba que construye el usuario, si existe.
  \item \texttt{global}: mantiene datos globales.
  \item \texttt{tempSave}: historial de comandos.
  \item \texttt{input}: datos de la entrada compuesta.
  \item \texttt{cc}: contador, número de líneas del usuario. 
\end{itemize}

\begin{verbatim}
data GlobalState = Global { fTypeContext :: FTypeContext
                          , lamDef :: LTD.LamDefs
                          , typeDef :: TD.TypeDefs
                          , conflict :: ConflictNames
                          }
\end{verbatim}

Este registro contiene los datos globales del asistente.
\begin{itemize}
  \item \texttt{fTypeContext}: variables de tipo libres.
  \item \texttt{lamDef}: lambda términos definidos.
  \item \texttt{typeDef}: representa a los operadores.
  \item \texttt{conflict}: nombre de lambda términos conflictivos. Es decir que, son nombres
    que coinciden con el espacio de nombres de las hipótesis.
\end{itemize}

\begin{verbatim}
data ProofState = PState { name :: String
                         , types :: (Type,TType)
                         , constr :: ProofConstruction
                         }
\end{verbatim}

Estado general de la prueba que realiza el usuario.
\begin{itemize}
  \item \texttt{name}: nombre de la prueba.
  \item \texttt{types}: tipo, con y sin nombres, que se quiere habitar. Se corresponde a fórmula que quiere probar el usuario.
  \item \texttt{constr}: construcción de la prueba.
\end{itemize}

\begin{verbatim}
data ProofConstruction = PConstruction { tsubp :: Int
                                       , subps :: [SubProof]
                                       , cglobal :: GlobalState
                                       , term :: LTermHoles
                                       }
\end{verbatim}

Prueba que realiza el usuario.
\begin{itemize}
  \item \texttt{tsubp}: cantidad total de subpruebas activas.
  \item \texttt{subps}: mantiene a todas las subpruebas activas.
  \item \texttt{cglobal}: datos globales vigentes durante la construcción de la prueba.
  \item \texttt{term}: representa al lambda término que va formando el usuario.
\end{itemize}

\begin{verbatim}
data SubProof = SP { termContext :: TermContext
                   , bTypeContext :: BTypeContext
                   , lsubp :: Int
                   , tvars :: Int
                   , ty :: [Maybe (Type, TType)]
                   }
\end{verbatim}

Representa a un conjunto de subpruebas.
Consideramos que todas ellas tienen el mismo contexto, comparten tanto los campos \texttt{termContext} como \texttt{bTypeContext}.
\begin{itemize}
  \item \texttt{termContext}: contexto de las variables de lambda terminos.
  \item \texttt{bTypeContext}: contexto de las variables de tipo ligadas. Nos referimos a las variables que corresponden a una cuantificación.
  \item \texttt{lsubp}: indica la cantidad de subpruebas que contiene.
  \item \texttt{tvars}: cantidad total de variables de tipo ligadas, y variables de términos.
  \item \texttt{ty}: tipos objetivos de cada subprueba.
\end{itemize}


Utilizamos el siguiente AST para representar a un lambda término:
\begin{verbatim}
  data LamTerm a b c = LVar b
                   | Abs a c (LamTerm a b c)
                   | BAbs TypeVar (LamTerm a b c)
                   | LamTerm a b c :@: LamTerm a b c
                   | LamTerm a b c :!: c
                   | EPack c (LamTerm a b c) c
                   | EUnpack TypeVar a (LamTerm a b c) (LamTerm a b c)
                   | LamTerm a b c ::: c
                   deriving (Show, Eq)
\end{verbatim}
  
Donde, \texttt{Type} es el AST de los tipos, y \texttt{TType} es el AST de los tipos sin nombres, es decir que estos emplean la notación De Bruijn.
\texttt{Type} nos es útil a la hora de imprimir en pantalla el tipo del lambda término, de modo tal que tenga casi el mismo tipo ingresado por el usuario 
(posible renombramiento de tipos).
Mientras que, \texttt{TType} lo usamos en todas las operatorias sobre los tipos de los lambda términos, por ejemplo, en la unificación de tipos, que
se realiza cuando se aplica la regla de eliminación del \textbf{para todo}.

A continuación, explicamos el data type utilizado para representar al lambda término que se construye de manera interactiva por el usuario.

\begin{verbatim}
data SpecialTerm = HoleT (Term->Term) | DoubleHoleT (Term->Term->Term) |
                   Term Term | TypeH TypeHole

data TypeHole = HTe ((Type, TType) -> Term) | HTy ((Type, TType) -> TypeHole)
\end{verbatim}

El data type \texttt{SpecialTerm} representa a un lamba término que puede tener dos tipos de agujero: lambda términos o tipos, de manera
exclusiva, es decir solo puede tener un solo tipo de agujero.

El data type \texttt{TypeHole} representa agujeros de tipos en un lambda término.

\section{Gramáticas}
 Gramática del lambda calculo.

\begin{tabbing}
$\langle lamterm \rangle$ \= $::=$ $\langle abs \rangle$ | $\langle term \rangle$ ( $\langle abs \rangle$ | $\varepsilon$ ) \\

$\langle term \rangle$ \> $::=$ $\langle term \rangle$ ($\langle unitterm \rangle$ | $\varepsilon$) \\

$\langle unitterm \rangle$ \> $::=$ \texttt{'('} $\langle lambterm \rangle$ \texttt{')'} |
$\langle var \rangle$ | $\langle unitterm \rangle$ \texttt{'['} $\langle typeterm \rangle$ \texttt{']'}\\

$\langle abs \rangle$ \> $::=$ \texttt{'$\lambda$'} $\langle var \rangle$ ( \texttt{':'} $\langle typeterm \rangle$ \texttt{'.'} $\langle lamterm \rangle$
| \texttt{'.'} $\langle lamterm \rangle$)
\end{tabbing}

Consideramos a $\langle var \rangle$, como la gramática de palabras alfanuméricas, incluido el guión bajo, exceptuando
las palabras reservadas: $Theorem$, $Definition$, $forall$, $False$.

Gramática del lambda calculo, sin recursión a izquierda.

\begin{tabbing}
$\langle lamterm \rangle$ \= $::=$ $\langle abs \rangle$ | $\langle term \rangle$ ( $\langle abs \rangle$ | $\varepsilon$ ) \\

$\langle term \rangle$ \> $::=$ $\langle unitterm \rangle$ $\langle term' \rangle$ \\

$\langle term' \rangle$ \> $::=$  $\langle unitterm \rangle$  $\langle term' \rangle$ | $\varepsilon$ \\

$\langle unitterm \rangle$ \> $::=$ $\langle unit \rangle$ $\langle unitterm' \rangle$ \\

$\langle unitterm' \rangle$ \> $::=$ \texttt{'['} $\langle typeterm \rangle$ \texttt{']'} $\langle unitterm' \rangle$ | $\varepsilon$ \\

$\langle unit \rangle$ \> $::=$ \texttt{'('} $\langle lambterm \rangle$ \texttt{')'} | $\langle var \rangle$ \\

$\langle abs \rangle$ \> $::=$ \texttt{'$\lambda$'} $\langle var \rangle$ ( \texttt{':'} $\langle typeterm \rangle$ \texttt{'.'} $\langle lamterm \rangle$
| \texttt{'.'} $\langle lamterm \rangle$)
\end{tabbing}

Gramática de fórmulas o tipos.

\begin{tabbing}
$\langle typeterm \rangle$ \= $::=$ $\langle unit_{1} \rangle$ \texttt{'<->'} $\langle typeterm \rangle$ | $\langle unit_{1}' \rangle$\\
$\langle unit_{1}' \rangle$ \= $::=$ $\langle unit_{2} \rangle$ ( \texttt{'->'} $\langle unit_{1}' \rangle$ | $\varepsilon$ ) 
| \texttt{'forall'} $\langle var \rangle$ \texttt{'.'} $\langle typeterm \rangle$\\
$\langle unit_{1} \rangle$ \= $::=$ $\langle unit_{2} \rangle$ ( \texttt{'->'} $\langle unit_{1} \rangle$ | $\varepsilon$ ) \\
$\langle unit_{2} \rangle$ \= $::=$ $\langle unit_{3} \rangle$ ( \texttt{'$\vee$'} $\langle unit_{2} \rangle$ | $\varepsilon$ ) \\
$\langle unit_{3} \rangle$ \= $::=$ $\langle infixOps \rangle$ ( \texttt{'$\wedge$'} $\langle unit_{3} \rangle$ | $\varepsilon$ ) \\
$\langle unit_{4} \rangle$ \= $::=$ $\langle unit_{5} \rangle$ | \texttt{'$\sim$'} $\langle unit_{4} \rangle$ |
$\langle prefixOps_{1} \rangle$ | $\langle prefixOps_{2} \rangle$ \\
$\langle unit_{5} \rangle$ \= $::=$ \texttt{'('} $\langle typeterm \rangle$ \texttt{')'} | $\langle var \rangle$ | 
$\langle prefixOps_{0} \rangle$

\end{tabbing}

Consideramos a $\langle prefixOps_{i} \rangle$, con $0 \leq i \leq 2$, como las gramáticas de los operadores prefijos definidos por el usuario.
Mientras que $\langle infixOps \rangle$ es la gramática de los operadores binarios infijos, el cual debe hacer referencia a $\langle unit_{4} \rangle$.

Precedencia de los operadores:
\setlist[enumerate,1]{start=0}
\begin{enumerate}
  \item \textit{Prefix ops.}
  \item $\sim$
  \item \textit{Infix binary ops.}
  \item $\wedge$
  \item $\vee$
  \item $\rightarrow$
  \item $\leftrightarrow$
  \item $forall$ (operador infijo)
\end{enumerate}

Los operadores con un valor de precedencia (\textit{pv}) alto tienen menos precedencia que otro con un valor más bajo.
Por ejemplo, $\wedge$ tiene más precedencia que $\vee$, pues $pv (\wedge) < pv (\vee)$.

\textit{Prefix ops.} es el conjunto de los todos los operadores prefijos definidos por el usuario. Consideramos
que todos ellos tienen la misma precedencia.
Mientras que \textit{Infix binary ops.} es el conjunto de los operadores infijos (binarios) declarados por el usuario.
Cada operador infijo que da el usuario, tiene asociado un valor de precedencia (el 2) y un valor de precedencia infija (\textit{ipv}).
Un nuevo operador infijo tiene un \textit{ipv} más alto que los operadores previamente declarados.
Es decir que, cada operador infijo tiene menos precedencia que aquellos que fueron declarados previamente.
Solo los operadores binarios infijos dados por el usuario mantienen un \textit{ipv}.

Consideramos que todos los operadores binarios infijos asocian a derecha.



\section{Observaciones}
\begin{itemize}
  \item El comando \texttt{apply} puede actuar como el comando \texttt{assumption}.

  \item La substitución que encuentra el algoritmo de unificación es un termino cerrado.
  
  \item Cuando se ingresa un tipo mediante el comando \texttt{Theorem}, posiblemente se lo renombre, de modo tal de que éste respete la siguiente
  convención.
  
  \textbf{Convención 1}: Sea \textit{t} un tipo. 
  En \textit{t}, no se declaran dos variables de tipo ligadas con el mismo nombre, una más anidada que la otra.
  Además, $BV (t) \cap (\Gamma_{t} \cup Props) = \emptyset$. Donde, $\Gamma_{t}$ es el conjunto de variables de tipo del contexto, y $Props$ es el conjunto
  de variables de tipos libres.
  
  La \textbf{Convención 1} se aplica al tipo del \textit{goal}.
  
  \item La \textbf{Convención 1} nos permite evitar la captura de variables, a la hora de realizar la sustitución generada por el comando \texttt{unfold},
  y que en el entorno de variables de tipos no se ingrese la misma variable más de dos veces (cuando se aplica \texttt{intro}).
 
  \item Cuando implementamos el comando \texttt{unfold}, nos aseguramos que el tipo resultado de la sustitución, respete la \textbf{Convención 1}.
  
  \item Al implementar el comando \texttt{intro} sobre un ``para todo'', no es necesario chequear que no la variable de tipo ligada no se encuentre
  en el contexto de tipos, pues ya sabemos que no está allí, gracias al renombramiento de variables de tipos ligadas.
  
  \item Construimos un lambda término $t$, tal que $t:\alpha$, donde $\alpha$ es el tipo (asociado a una fórmula lógica), dado por el usuario. El isomorfismo
  de Curry-Howard, nos permite relacionar a los tipos con fórmulas lógicas, y a las pruebas con lambda términos.
  El lambda término $t$, se construye a partir de la prueba que da el usuario.
  El teorema de Curry-Howard, nos asegura que, si $t:\alpha$, entonces la fórmula asociada a $\alpha$ es válida.
  
  \item La función \texttt{habitar} se encarga de construir el lambda término asociado a la prueba que va dando el usuario.
  A cada regla de la deducción natural del sistema IFC, le corresponde una regla de tipo, en el lambda cálculo simplemente
  tipado. ¿Como construimos el término $t$, asociado a una prueba lógica?.
  A cada aplicación de una regla de tipo, le corresponde un lambda término ``vació''.
  Es decir, si se busca un lambda término de tipo $\beta \rightarrow \gamma$, por ejemplo, y se lo quiere construir mediante la regla 
  de tipo \textbf{T-Abs}, entonces, tenemos el término vació, $t_{1} = \lambda x:\beta. \; ?$, donde $? : \gamma$.
  Representamos a los términos vacíos, mediante funciones, en el caso anterior, tendríamos la función:

  \begin{verse}
  $t_{1}$ :: \texttt{Term} $\rightarrow$  \texttt{Term} \\
  $t_{1}$ $t$ = $\lambda x:\beta. \; t$
  \end{verse}

  Donde, \texttt{Term} es el tipo de los lambda términos. El argumento que se le pase a $t_{1}$, debería tener tipo $\gamma$.
  Esto se chequea de acuerdo a qué regla de tipo quiere aplicar el usuario.
  Por lo tanto, $t = (t_{1} . t_{2} \dots t_{n-2} . t_{n-1}) \; t_{n}$, donde $t_{n}$ es un lambda término no vació, que sirve de argumento a la composiciones
  de funciones. Cada $t_{i}$, con $i \in \{ 1 \dots n \}$, se corresponde con una regla de tipado, que a su vez se corresponde con una regla de deducción natural, 
  que da el usuario.
  
  \item Una subprueba se corresponde a un nodo en el árbol de derivación de la fórmula. Las tácticas que ingresa el usuario construyen dicho árbol,
  así se obtiene el lambda término que lo representa. La demostración de una fórmula puede requerir la prueba de otras fórmulas. Por ejemplo,
  en la demostración $\vdash (p \rightarrow p) \wedge (q \rightarrow q)$, al aplicar la introducción del and, se genera dos nuevas subpruebas.
  
  % \begin{prooftree}
  % \[
  % \[
  % p
  % \using
  % {ass}
  % \justifies
  % p
  % \]
  % \using
  % {i_{\rightarrow}}
  % \justifies
  % p \rightarrow p
  % \]
  % \[
  % \[
  % q
  % \using
  % {ass}
  % \justifies
  % q
  % \]
  % \using
  % {i_{\rightarrow}}
  % \justifies
  % q \rightarrow q
  % \]
  % \using
  % {i_{\wedge}}
  % \justifies
  % (p \rightarrow p) \wedge (q \rightarrow q)
  % \end{prooftree}
  
  En el asistente tendríamos lo siguiente:
  
  \begin{verbatim}
  > Theorem t1: (p -> p) /\ (q -> q).
  Hay 1 sub pruebas.

  p : Prop
  q : Prop
  ___________________[1/1]
  (p -> p) /\ (q -> q)
  > split.
  Hay 2 sub pruebas.

  p : Prop
  q : Prop
  ___________________[1/2]
  p -> p
  ___________________[2/2]
  q -> q
  \end{verbatim}
  
  Cuando se demuestra una fórmula, decimos que la subprueba termina.

  Podemos ver en la Figura \ref{Estados}, la aplicación del algoritmo de control de las subpruebas, al resolver el teorema:
  $p, q \vee  (p \rightarrow t) \rightarrow  r, t, p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w \vdash w$.
  En dicho diagrama consideramos a $C = H0 : p, H1 : q \vee  (p \rightarrow t) \rightarrow  r, H2 : t, H3: p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w$.
  Empleamos la siguiente notación:
  
  \tikz \node[rectangle,draw,label=below:
  Estado de $subps$]{Conjunto de pruebas};
  
  Donde la transición de un estado a otro se realiza a partir de un comando.

  \begin{figure}  
  \begin{tikzpicture}[->, node distance=2cm, auto, thick,main node/.style={rectangle,draw}]

  \node[main node, label={[align=left]below:$subps = [s_{0}]$\\$\wedge \; ty \; s_{0} = [w]$}] (1) {$C \vdash  w$};
  \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\ $\wedge \; ty \; s_{1} = [p \wedge q]$ \\ $\wedge \; ty \; s_{0} = [r,t]$}] 
  (2) [right=of 1] {$C \vdash  p \wedge t$, $C \vdash r$, $C \vdash q \vee t$};
  \begin{scope}[node distance=1.4cm]
  \node[main node, label={[align=left]below:$subps = [s_{2},s_{1},s_{0}]$\\$\wedge \; ty \; s_{2} = [p]$
  \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}]
  (3) [right=of 2] {$C \vdash  p , C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \begin{scope}[node distance=1cm]
  \coordinate [right=of 3] (4) {};
  \end{scope}
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}] 
  (5) [below=of 4] {$C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \begin{scope}[node distance=2.3cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [r]$ \\ $\wedge \; ty \; s_{0} = [q \vee t]$}] 
  (6) [left=of 5] {$C \vdash r$, $C \vdash q \vee t$};
  \end{scope}
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [q \vee  (p \rightarrow t)]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (7) [left=of 6] {$C \vdash q \vee  (p \rightarrow t)$, $C \vdash t$};
  \coordinate [left=of 7] (8) {};
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [p \rightarrow t]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (9) [below=of 8] {$C \vdash p \rightarrow t$, $C \vdash t$};
  \end{scope}
  \begin{scope}[node distance=1.5cm]
  \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [t]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (10) [right=of 9] {$\{C, H4: p \}\vdash t$, $C \vdash t$};
  \end{scope}
  \begin{scope}[node distance=2.8cm]
  \node[main node, label={[align=left]below:$subps = [s_{0}]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
  (11) [right=of 10] {$C \vdash t$};
  \node[main node, label={[align=left]below:$subps = [\;]$}] 
  (12) [right=of 11] {$\emptyset$};
  \end{scope}
  \path[draw] (1) edge [above] node {\texttt{apply H0}} (2) (2) edge [above] node {\texttt{split}} (3)
  (3) -- (4) (4) edge node [left] {\texttt{assumption}} (5) (5) edge node [above] {\texttt{assumption}} (6) 
  (6) edge node [above] {\texttt{apply H1}} (7) (7) -- (8) (8) -- node [right] {\texttt{right}} (9)
  (9) edge node [above] {\texttt{intro}} (10) (10) edge node [above] {\texttt{assumption}} (11)
  (11) edge node [above] {\texttt{assumption}} (12);
  \end{tikzpicture}
  \caption{Diagrama de estados.} \label{Estados}
  \end{figure}
  
  
  \item Aunque halla un lambda término con variables de tipo que tengan el mismo nombre que las variables de términos, su semántica de tipos está
  bien determinada.
  
  \item Al hacer el parser del lambda cálculo, asumí que la aplicación de tipos tiene más precedencia que la aplicación de términos, ¿está bien?.
  Ejemplo: $x \; y \; [A] = x \; (y \; [A]).$
  
  \item El pretty printer de los tipos o fórmulas, no utiliza la menor cantidad de paréntesis, cuando hay un \texttt{para todo} y \texttt{<->}.
  Por ejemplo \texttt{forall x, x <-> forall y, y}; se imprime así: \texttt{forall x, x <-> (forall y, y)}.
  
  \item Coq permite iniciar una nueva prueba de un teorema cuando la actual prueba no ha concluido.
  Sin embargo, solo se puede ``usar'' un teorema cuando ha sido probado mediante \textit{Proof}, y \textit{Qed}.
  
  \item Coq en algunos casos nos devuelve, mediante el comando \texttt{Print}, un lambda término ``incompleto'', al cual no es posible encontrarle
  un tipo mediante el comando \texttt{Check}. Ver \textit{Theorem k12}, en \texttt{plantilla\_p2.v}.
  
  \item En la implementación de la regla de tipado, correspondiente a la introducción del existe, consideramos que $t_{2}$ debe tener un tipo equivalente
  a $T_{2}[X:=U]$, llamemos lo $T$. Es decir que $T$ puede variar de $T_{2}[X:=U]$, con respecto a los nombres de las variables de tipo ligadas que aparecen en 
  el segundo.
  Hacemos esto para respetar la \textbf{Convención 1}. 
  
  El tipo $T$ lo calcula la función \texttt{applyTypes}. Para ello, realiza la sustitución $T_{2}[X:=U]$, más un renombramiento que respete la \textbf{Convención 1}.
  Ver Ejemplo 7, en los casos de inferencia OK.
  
%   \item El comando \texttt{exact} puede recibir un tipo cuando la unificación no puede precisar
%   una instancia de tipo.
%   Decidimos utilizar la palabra reservada $type$, para identificar que \texttt{exact} toma un tipo.
%   Si no hiciésemos esto, en ciertos casos no podríamos determinar si lo que recibe \texttt{exact} es un
%   tipo o un lambda término.
  
  \item Permitimos definir un teorema cuyo nombre sea el nombre de una hipótesis del contexto de
  su prueba. De todas formas, esto no sería un problema.
  
  \item Consideramos dos espacios de nombres para las variables.
  \begin{itemize}
    \item $v.términos = v.ligadas_{te} \cup v.libres_{te}$
    \item $v.libres_{te} = teoremas$
    \item $v.tipos = v.ligadas_{ti} \cup v.libres_{ti}$
    \item $v.libres_{ti} = proposiciones \cup operadores$
  \end{itemize}
  
  Donde, $v.ligadas_{ti} \cap v.libres_{ti} = \emptyset$, para satisfacer la \textbf{Convención 1}.
  Además, $v.libres_{te} \cap v.libres_{ti} = \emptyset$, para desambiguar las aplicaciones de variables.
  
  También, consideramos para cada prueba, $hipótesis \cap teoremas = \emptyset$. De lo contrario, tendríamos conflictos de nombres.
  
  \item Cuando se incluye un tipo en un lambda término mediante el constructor $as$, se puede producir un error de parseo, si no se lo
  incluye entre paréntesis. Por ejemplo, aplicaciones de variables de lambda términos documentadas mediante $as$, pueden entenderse
  como un tipo. Ejemplo: $\lambda a.\lambda x:a. \lambda y:a \rightarrow a. y \; as \; a \rightarrow a \; x \; as \; a$,
  es incorrecto. Lo correcto es: $\lambda a.\lambda x:a. \lambda y:a \rightarrow a. y \; as \; (a \rightarrow a) \; x \; as \; a$
  
  \item No renombramos el tipo asociado al \textit{as} de un lambda término, pues no es necesario.
  

\end{itemize}


\begin{thebibliography}{9}
\bibitem{pierce} 
  Benjamin C. Pierce. 
  Types and Programming Languages. 2002.

\bibitem{languageEng}
  Ana Bove, Luís Soares Barbosa,
  Alberto Pardo, y
  Jorge Sousa Pinto.
  Language Engineering and Rigorous Software Development.
  Springer, 2009.

\bibitem{curry-howard}
  Morten Heine Sørensen, y Pawel Urzyczyn.
  Lectures on the Curry-Howard Isomorphism.
  2006

\end{thebibliography}


\end{document}
