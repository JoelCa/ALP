Casos probados:

Props p q.

Casos con existenciales:
- Theorem t1 : (forall x, x -> x) -> (exists x, x -> x) -> (exists x, x -> x).
Para chequear que el para todo unifica con el existe.
- Theorem t2 : p -> (exists x, p -> x) -> (exists y, y).
Para chequear eliminación de existe. ARREGLAR pretty printer del término. (VER)
- Theorem t3: (exists y, forall x, x -> y) -> (forall x, exists y, x -> y).
Para chequear eliminación de existe. NO chequee el lambda termino.

Casos sin existenciales:
- Theorem t4: (forall x, forall y, forall z, y -> y) -> (p -> p).
Para ver que los tipos "vacios" se instancian correctamente.
- Theorem t5: (forall a, (forall c, a)  -> (forall c, a)) -> (forall c, p) -> (forall c, p).
Arreglado. Cambiamos la forma con que se añadían las susbtituciones a la estructura Map.
- Theorem t6: (forall a, forall b, a -> b) -> p -> q.
Arreglado. Se Generaba un lambda término con las instancias al reves. La solución es es la misma
del teorema t5.
- Theorem t7: forall as, forall we, as -> (forall jk, jk) -> we.
Para chequear que se imprima bien el lambda término.
- Theorem t8 : (forall qw, qw /\ qw) -> forall nm, nm /\ nm.
Para chequear que se imprima bien el lambda término.
- Theorem t9 : p -> q -> (p /\ (p /\ q)) /\ q.
Para chequear que funcione bien el algoritmo que maneja la construcción de las subpruebas.
- Props p q r t y.
  Theorem t10: p -> q -> r -> t -> (p -> q -> r -> t -> y) -> y.
Para chequear el pretty printer de las subpruebas, con el nuevo algoritmo.
¿Qué hacer cuando variable de tipo es el igual a variable de término? NO hay problema.
- Theorem t11: (forall b, (forall a, a) -> (forall w, forall r, b) -> b) -> 
    (forall o, forall w, (forall x, x) -> (forall dd, forall ee, (forall zz, o)) -> (forall kk, o)).
Para probar la unificación y el pretty printer.
- Theorem t12: forall a, forall b, (a -> b) -> (forall c, forall d, a -> b).
Para probar el comando apply.
- Theorem t13: forall o, (forall b, (forall a, a) -> (forall c, forall d, b) -> b) -> (forall a, a) -> (forall w, forall r, (forall t, o /\ t)) -> (forall t, o /\ t).
Para probar la unificación.
- Theorem t14: forall d, (forall a, a -> d)-> forall b, forall c, b -> d.
Para probar la unificación.
- Theorem t15: forall b, forall c, (forall a, a -> c) -> b -> c.
Para probar la unificación.
-Theorem t16: forall b, forall c, (forall a, a -> c) -> forall qq, (forall h, h -> c).
Para probar la unificación.
- Theorem tt17 : forall a, forall b, a /\ b -> a.
  Theorem tt17' : forall p, forall q, forall r, p /\ q -> (p -> r) -> r.
Para probar el comando exact en la prueba de tt17', de la siguiente manera:
exact (H1 (tt17 [p] [q] H0)).
- Theorem t18: (forall x, forall y, forall z, x -> z) -> (forall x, forall z, x -> z). 
Para chequear si podemos instanciar el tipo "vacio", mediante "exact".
- Definition x <--> y := (x -> y) /\ (y -> x).
  Theorem t19: forall x, forall y, x /\ y -> x <--> y.
  Theorem t20: forall g, forall w, (g <--> w) -> (g -> w).
Para chequear la definición de operandos.
- Definition x -- y := forall w, (w /\ x) /\ y -> w.
  Theorem t21: forall w, forall p, w -> p -> (forall p, p /\ w \/ w) -- (forall w, forall p, w /\ p).
Para chequear el renombre de variables de tipo ligadas en el unfold.
- Definition x ^ y := forall w, forall v, x /\ y /\ w \/ v -> x /\ y.
  Theorem t22: forall w, forall v, w -> v -> w ^ (forall v, forall w, v -> w).
Para chequear el renombre de variables de tipo ligadas en el unfold.
- Theorem t23: forall o, forall t, (forall w,  forall r, o /\ w) -> (o /\ t).
Para chequear la unificación (este caso no unificaba y lo arregle).
- Theorem t24: p -> q -> (((p /\ q) /\ (p /\ p)) /\ q) /\ p.
Para chequear el pretty printer de la prueba, y el inferidor sobre el lambda término de la prueba.
- Definition x x y := forall w, forall v, x /\ y.
  Theorem t25 : forall w, forall y, x w y -> x w y.
Para probar el parseo (antes no se parseaba bien).
- Theorem t26: forall w, forall y,  w /\ y -> w \/ y.
Para probar que puede inferirse el tipo del lambda término asociado
- Theorem t27: p -> p <-> p -> p.
Para probar el pretty printer (precedencias).
- Definition fun1 w := forall x, w -> x -> w.
  Definition fun2 w := forall x, w -> x -> x -> w.
  Theorem t28:fun1 (fun2 p).
Para probar el pretty printer (precedencias).
- Theorem t29: p -> p \/ p /\ p \/ q.
Para probar el pretty printer (precedencias).
- Theorem t30: p -- q ^ q -- p.
Para probar el pretty printer (precedencias).
- Definition q ++ k := forall x, x -> q -> q.
  Theorem t31: p -- q ^ q -- p ++ q.
Para probar el pretty printer (precedencias).
- Theorem t32: (p -- q ^ q -- p) ^ (q ++ q) ^ p.
Para probar el pretty printer (precedencias).
- Theorem t33: ~p \/ fun1 p.
Para probar el pretty printer (precedencias).
NO funciona el inferidor sobre el lambda término que se obtiene de la prueba.
- Theorem t34: forall x, x -> x /\ (x <-> x).
NO funciona el inferidor sobre el lambda término que se obtiene de la prueba.
- Theorem t35: False -> ~p.
Para probar la táctica de eliminación del bottom.
- Definition fun3 w y := forall x, w -> x -> y -> w.
  Theorem t36: fun3 p q -> fun2 q.
Para probar el pretty printer (precedencias).
- Theorem k37: fun1 p /\ (p -> p).
Para probar el pretty printer (precedencias).
- Theorem k38: forall bb, forall aa, aa -> (forall aa0, aa0 -> aa).
Probar con "intro" y "exact (\aa.\x:aa.\aa.\y:aa.x)". Para chequear el renombramiento de var. de tipo
en el lambda término final.
- Theorem k39: forall x, forall y, (x -> ~y) -> y -> x -> ~x.
Para probar "cut" y "absurd".
