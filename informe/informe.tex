\documentclass[a4paper,11pt]{article}
\usepackage[left=1.5cm,top=2.0cm,right=1.5cm,bottom=2.0cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern,bm}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{bussproofs}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage{amsthm}

\newtheorem{theorem}{Teorema}
\theoremstyle{definition}
\newtheorem{definition}{Definición}
\theoremstyle{remark}
\newtheorem{invariant}{Invariante}

\usetikzlibrary{positioning, babel,shapes}
\newdimen\nodeDist
\nodeDist=35mm

\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{}
\author{}

\begin{document}

\maketitle 

\thispagestyle{empty}
\begin{center}
\section*{Análisis de lenguajes de programación} 
\subsection*{Asistente de prueba de la lógica proposicional constructiva de segundo orden}
\end{center}

\newpage{\pagestyle{empty}\cleardoublepage}

\tableofcontents

\newpage


\section{Motivación}
Es de especial intereses para el autor entender la cual es la relación que existe entre la lógica y el lambda cálculo.
Por ello decide implementar un asistente de prueba, cuya construcción se basa en la correspondencia
entre el Sistema F, y la lógica proposicional constructiva de segundo orden, dado por la correspondencia de Curry-Howard.
 
\section{Fórmulas como tipos}
Podemos interpretar $M : \sigma$ de dos formas:
\begin{itemize}
  \item Término como programa, tipo como especificación: $M$ es una función de tipo $\sigma$.
  \item Tipo como una fórmula, término como su prueba: $M$ es una prueba de la fórmula $\sigma$.
\end{itemize}

La correspondencia Curry-Howard, fórmulas como tipos, es una correspondencia uno a uno entre términos
tipados del lambda cálculo y las derivaciones en la lógica proposicional minimal.
Desde el punto de vista de la lógica: $x_{1}:\tau_{1}, x_{2}:\tau_{2}, \ldots, x_{n}:\tau_{n} \vdash M : \sigma$,
puede leerse como $M$ es una prueba de $\sigma$ a partir de las hipótesis $\tau_{1}, \tau_{2}, \ldots, \tau_{n}$.  
 


\begin{definition}
El sistema de lógica proposicional PROP restringido al conectivo de implicación se define de la siguiente manera.

\begin{itemize}
  \item Sintaxis abstracta:
  
  $prop ::= PropVar \; | \; (prop \rightarrow prop)$.
  
  \item Reglas de inferencia. Donde $\Delta$ es un conjunto de proposiciones, $\sigma$ y $\tau$ son proposiciones.
    
    \begin{minipage}[t]{0.3\linewidth}
      \centering
      \begin{prooftree}
        \AxiomC{$\sigma \in \Delta$}
        \UnaryInfC{$\Delta \vdash \sigma$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      \centering

      \begin{prooftree}
        \AxiomC{$\sigma \rightarrow \tau \hspace{0.5cm} \sigma$}
        \RightLabel{\scriptsize \textsc{E-$\rightarrow$}}
        \UnaryInfC{$\tau$}
      \end{prooftree}
      
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      \centering
      \begin{prooftree}
        \AxiomC{ $[\sigma]^{j}$}
        \noLine
        \UnaryInfC{$\vdots$}
        \noLine
        \UnaryInfC{$\tau$}        
        \RightLabel{\scriptsize \textsc{I-$\rightarrow^{[j]}$}}
        \UnaryInfC{$\sigma \rightarrow \tau$}
      \end{prooftree}
      
    \end{minipage}
   
\end{itemize}

Decimos que $\Delta \vdash_{Prop} \sigma$ si existe una derivación usando las reglas, con conclusión $\sigma$ y hipótesis en $\Delta$.
\end{definition}

Procedemos a definir lo que entendemos por fórmulas como tipos. Para ello consideramos al contexto en PROP como listas
($\Delta$ es una lista en la siguiente definición).


\begin{definition}
  La noción de prueba como término, es decir, derivaciones de PROP a términos del lambda cálculo simplemente tipado $\lambda_{\rightarrow}$, 
  se define inductivamente como sigue.

  Asociamos a las listas de proposiciones $\Delta$ un contexto $\Gamma$, en donde se reemplaza $\sigma$ en $\Delta$ con $x_{i} : \sigma_{i} \in \Gamma$.
  Del lado izquierdo vemos la clausula inductiva de la derivación y en el lado derecho, se describe del lado superior a la línea,
  los términos que tenemos por inducción, y debajo, el término asociado a la derivación.

  \vspace{0.5cm}

  \begin{minipage}[t]{0.4\linewidth}
    \centering

    \begin{prooftree}
      \AxiomC{$\sigma \in \Delta$}
      \UnaryInfC{$\Delta \vdash \sigma$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\sigma \rightarrow \tau \hspace{0.5cm} \sigma$}
      \UnaryInfC{$\tau$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC { $[\sigma]^{j}$}
      \noLine
      \UnaryInfC{$\vdots$}
      \noLine
      \UnaryInfC{$\tau$}        
      \UnaryInfC{$\sigma \rightarrow \tau$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}
    \centering

    \begin{prooftree}  
      \AxiomC{$x : \sigma \in \Delta$}
      \UnaryInfC{$\Gamma \vdash x : \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma_{1} \vdash M : \sigma \rightarrow \tau$}
      \AxiomC{$\Gamma_{2} \vdash N : \sigma$}
      \BinaryInfC{$\Gamma_{1} \cup \Gamma_{2} \vdash M \; N : \tau$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma,x:\sigma \vdash M : \tau$}
      \UnaryInfC{$\Gamma \vdash \lambda x : \sigma. \; M : \sigma \rightarrow \tau$}
    \end{prooftree}

  \end{minipage}

  \vspace{0.5cm}

  Si $\mathcal{D}$ es una derivación en PROP, entonces $\overline{\mathcal{D}}$ es un lambda término en $\lambda_{\rightarrow}$.
\end{definition}

El siguiente teorema se extrajo de \textit{Language Engineering and Rigorous Software Development} \cite{languageEng}. 

\begin{theorem}
  Soundness, Completitud de formulas como tipos.

  \begin{enumerate}
  \item Si $\mathcal{D}$ es una deducción natural en PROP con conclusión $\sigma$ y hipótesis en $\Delta$, entonces
    $\bm{x}:\bm{\Delta} \vdash \overline{\mathcal{D}} : \sigma$, en $\lambda_{\rightarrow}$.
  \item Si $\Gamma \vdash M : \sigma$ en $\lambda_{\rightarrow}$, entonces hay una derivación de $\sigma$ desde $\Delta$ en PROP,
    donde $\Delta$ es $\Gamma$ sin la asignación de variables.
  \end{enumerate}

\end{theorem}

La correspondencia fórmulas como tipos constituye un isomorfismo entre derivaciones en PROP y términos bien formados en $\lambda_{\rightarrow}$.
Dicho de otra manera, una fórmula es teorema si y solo si es un tipo habitado.

\subsection{Lambda cálculo con polimorfismo}
\label{Lambda cálculo con polimorfismo}

El lambda cálculo con polimorfismo (Sistema F) sirve como una notación de las pruebas de la lógica proposicional constructiva
de segundo orden.
Comenzamos definiendo al Sistema F.

\begin{definition}
  Los tipos del Sistema F, estilo Church, son:

  $Typ := TVar \; | \; (Typ \rightarrow Typ) \; | \; \forall \alpha . Typ$

  Mientras que las reglas de tipos son :

  \begin{minipage}[t]{0.4\linewidth}
    \centering

    \begin{prooftree}  
      \AxiomC{$x : \sigma \in \Gamma$}
      \UnaryInfC{$\Gamma \vdash x : \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma_{1} \vdash M : \sigma \rightarrow \tau$}
      \AxiomC{$\Gamma_{2} \vdash N : \sigma$}
      \BinaryInfC{$\Gamma_{1} \cup \Gamma_{2} \vdash M \; N : \tau$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma,x:\sigma \vdash M : \tau$}
      \UnaryInfC{$\Gamma \vdash \lambda x : \sigma. \; M : \sigma \rightarrow \tau$}
    \end{prooftree}

  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}

    \begin{prooftree}  
      \AxiomC{$\Gamma \vdash M : \sigma$}
      \RightLabel{$\alpha \notin FV(\Gamma)$}
      \UnaryInfC{$\Gamma \vdash \lambda \alpha. M : \forall \alpha. \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma \vdash M : \forall \alpha. \sigma$}
      \UnaryInfC{$\Gamma \vdash : \sigma [ \alpha := \tau]$}
    \end{prooftree}
    
  \end{minipage}
\end{definition}

\begin{figure}
  \centering
  \begin{minipage}[t]{0.35\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Términos: \\
        t \hspace{-0.1cm} ::= x \\ 
        \> $\mathtt {\lambda x : T. \; t}$ \\
        \> t t \\
        \> $\lambda$X. t \\
        \> t [T] \\
        \> \{$^{*}$T, t\} as T \\
        \> let \{X, x\} = t in t \\
        \> t as T
      \end{tabbing} 
    }
  \end{minipage}
  \begin{minipage}[t]{0.3\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Contexto: \\
        $\Gamma$ \hspace{-0.1cm} ::= $\emptyset$ \\
        \> $\Gamma$, x:T \\ 
        \> $\Gamma$, X
      \end{tabbing} 
    }
  \end{minipage}
  \begin{minipage}[t]{0.3\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Tipos: \\
        T \hspace{-0.1cm} ::= X \\
        \> T $\rightarrow$ T \\
        \> forall X, T \\
        \> exists X, T 
      \end{tabbing} 
    }
  \end{minipage}

  \texttt{Reglas de tipos}

  \begin{minipage}[t]{0.4\linewidth}
    \centering
    
    \begin{prooftree}  
      \AxiomC{$\mathtt{x : T \in \Gamma}$}
      \RightLabel{\scriptsize \textsc{T-Var}}
      \UnaryInfC{$\mathtt{\Gamma \vdash x : T}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : T_{11} \rightarrow T_{12} \quad \Gamma \vdash t_{2} : T_{11}}$}
      \RightLabel{\scriptsize \textsc{T-App}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} t_{2} : T_{12}}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma, x: T_{1} \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-Abs}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \lambda x: T_{1}. \; t_{2} : T_{1} \rightarrow T_{2}}$}
    \end{prooftree}
    
    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{2} : T_{2} [X \rightarrow U]}$}
      \RightLabel{\scriptsize \textsc{T-Pack}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \{^{*}U, t_{2}\} \; as \; exists \; X,\;  T_{2}}$}
      \noLine
      \UnaryInfC{$\mathtt{: exists \; X,\;  T_{2}}$}
    \end{prooftree}

  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}
    \centering  

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma, X \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-TAbs}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \lambda X. \; t_{2} : forall \; X, \; T_{2}}$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : forall \; X, \; T_{12}}$}
      \RightLabel{\scriptsize \textsc{T-TApp}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} \; [T_{2}] : T_{12} [X \rightarrow T_{2}]}$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : T}$}
      \RightLabel{\scriptsize \textsc{T-Ascribe}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} \; as \; T : T}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : exists \; X, \; T_{12} }$}
      \AxiomC{$\mathtt{\Gamma, X, x:T_{12}  \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-Unpack}}
      \BinaryInfC{$\mathtt{\Gamma \vdash let \{ X, x \} = t_{1} \; in \; t_{2} : T_{2}}$}
    \end{prooftree}
    
  \end{minipage}
  \caption{Sintaxis y reglas de tipos del Sistema F extendido.}
  \label{SintaxisTiposF}
\end{figure}

Implementamos el Sistema F siguiendo las reglas de inferencia de tipos que presenta Pierce \cite{pierce}.
Ver Figura \ref{SintaxisTiposF}.
Se decidió extenderlo con el inclusión del cuantificador existencial, y la adscripción de un tipo a término.

El sistema F, permite la abstracción tanto de términos como tipos. Con lo cual podemos ``definir'' nuevos
constructores de tipos, a partir del lenguaje, como se muestra a continuación.

\begin{definition}
  Definición de operadores de la lógica intuicionista.

  \begin{itemize}
  \item $\bot := \forall \alpha. \alpha$
  \item $\sigma \wedge \tau := \forall \alpha. (\sigma \rightarrow \tau \rightarrow \alpha) \rightarrow \alpha$
  \item $\sigma \vee \tau := \forall \alpha. (\sigma \rightarrow \alpha) \rightarrow (\tau \rightarrow \alpha) \rightarrow \alpha$
  \item $\neg \alpha := \alpha \rightarrow \bot$
  \item $\alpha \leftrightarrow \beta := (\alpha \rightarrow \beta) \wedge (\beta \rightarrow \alpha)$ 
  \end{itemize}
\end{definition}

A partir de la definición anterior es posible definir las reglas de introducción y eliminación
de los operadores $\bot, \wedge,$ y $\vee$.

Sabemos que es posible describir al existencial de la siguiente manera:
$\exists \alpha. \sigma := \forall \beta. (\forall \alpha. \sigma \rightarrow \beta) \rightarrow \beta$.
Sin embargo, creemos que no es posible dar su regla de introducción y eliminación mediante un lambda término.
Por ello, decimos mapear la introducción y eliminación del existencial con reglas de inferencia de tipo (\texttt{T-Pack}, y \texttt{T-Unpack}).

Para más información ver \textit{Lectures on the Curry-Howard Isomorphism} \cite{curry-howard}.

\section{Instalación}

El código fuente se encuentra en: \url{https://github.com/JoelCa/ALP/tree/master/proofAssistant}.
La instalación se realiza mediante $stack$ (Stack Version 1.5.1, Cabal Version 2.0.0.0). 
Desde el directorio raíz del código fuente hacer:

\begin{verbatim}
$ stack setup
$ stack build
$ cd app
$ stack exec proofAssistant
\end{verbatim}

Nos movemos al directorio \texttt{app} para que el ejecutable \texttt{proofAsistant} encuentre el archivo 
\texttt{Prelude.pr}. Este archivo contiene la definición de operadores básicos, junto con sus reglas de introducción y eliminación.

\section{Construcción de pruebas}
\label{construcciónDePruebas}

% El isomorfismo de Curry-Howard, nos permite relacionar a los tipos con fórmulas lógicas, 
% y a las pruebas con lambda términos.

El asistente de prueba implementa el isomorfismo Curry-Howard.
Cuando se prueba una fórmula $\alpha$, se construye un lambda término $t$, tal que $t:\alpha$.
Es decir que, cuando la prueba finaliza el lambda término asociado a la prueba tendrá como tipo la fórmula probada.
Por lo tanto, si $t:\alpha$, entonces la fórmula asociada a $\alpha$ es válida.

De ahora en adelante, cuando hablemos de una prueba posiblemente nos estemos refiriendo al lambda término asociado a la prueba lógica.
Además, tratamos de manera indistinta a una fórmula de un tipo.

Para probar cierta fórmula utilizaremos diferentes tácticas que transforman el objetivo original e
introducen hipótesis adicionales.

Cuando construimos una prueba tenemos la siguiente situación:
existen varios objetivos a probar, cada uno a partir de ciertas hipótesis.
\newline

\begin{minipage}[t]{0.1\linewidth}
  \AxiomC{$\Gamma_{1}$}
  \UnaryInfC{$\alpha_{1}$}
  \DisplayProof    
\end{minipage}
\begin{minipage}[t]{0.07\linewidth}
  \AxiomC{$\Gamma_{2}$}
  \UnaryInfC{$\alpha_{2}$}
  \DisplayProof    
\end{minipage}
\begin{minipage}[t]{0.05\linewidth}
  $\ldots$
\end{minipage}
\begin{minipage}[t]{0.1\linewidth}
  \AxiomC{$\Gamma_{n}$}
  \UnaryInfC{$\alpha_{n}$}
  \DisplayProof    
\end{minipage}
\newline

Tenemos que,

\begin{itemize}
\item Cada $\Gamma_{i}$ (contexto) es un conjunto de fórmulas (hipótesis) y variables. donde las hipótesis
son de la forma H0 : $\gamma_{0}$, $\ldots$, Hk : $\gamma_{k}$.
\item $\alpha_{i}$ es una fórmula, la cual debe ser probada a partir de $\Gamma_{i}$. 
\end{itemize}


\begin{figure}[!h]
  \centering
  \begin{tikzpicture}
    %% vertices
    \draw[fill=black] (1,0) circle (3pt);
    \draw[fill=black] (5,1.5) circle (3pt);
    \draw[fill=black] (3,1.5) circle (3pt);
    \draw[fill=black] (5,3) circle (3pt);
    %% vertex labels
    \node at (4.8,3)
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{1}$}
        \UnaryInfC{$\alpha_{1}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (2.7,1.5) 
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{11}$}
        \UnaryInfC{$\alpha_{11}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (4.7,1.5) 
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{12}$}
        \UnaryInfC{$\alpha_{12}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (7,1.5) 
    {
      \ldots
    };
    \node at (0.5,0)
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{111}$}
        \UnaryInfC{$\alpha_{111}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (3,0) 
    {
      \ldots
    };
    \node at (5,0) 
    {
      \ldots
    };
    \node at (1,-1.5) 
    {
      \ldots
    };
    %%% edges
    \draw[thick] (1, -1.3) -- (1,0) (5,0.2) -- (5,3) (3,0.2) -- (3,1.5) (1,0) -- (3,1.5) (7,1.7) -- (5,3)  (3,1.5) -- (5,3)  (5,1.5) -- (5,3);
  \end{tikzpicture}
  \caption{Árbol de prueba} \label{arbol}
\end{figure}

Las tácticas modifican el contexto durante una prueba, transformando un secuente en cero o más secuentes. Ver Figura \ref{arbol}.

La función \texttt{habitar}\footnote{Se encuentra en el archivo \texttt{Tactics.hs}.} se encarga de construir el lambda término asociado 
a la prueba que va dando el usuario.
Vimos que a cada regla de la deducción natural $PROP$, le corresponde una regla de tipo, en el lambda cálculo simplemente
tipado. Ahora bien, ¿como construimos el lambda término $t$, asociado a una prueba lógica?.
A cada aplicación de una regla de tipo, le corresponde un lambda término \textit{vacío}.
Es decir, si se busca un lambda término de tipo $\beta \rightarrow \gamma$, por ejemplo, y se lo quiere construir mediante la regla 
de tipo \textbf{T-Abs}, entonces, tenemos el término vacío, $t_{1} = \lambda x:\beta. \; ?$, donde $? : \gamma$.
Consideramos a los términos vacíos como funciones. En el caso anterior, tendríamos la función:

\begin{verse}
  $t_{1}$ :: \texttt{LamTerm} $\rightarrow$  \texttt{LamTerm} \\
  $t_{1}$ $t$ = $\lambda x:\beta. \; t$
\end{verse}

Donde, \texttt{LamTerm} es el tipo de los lambda términos. El argumento que se le pase a $t_{1}$, debería tener tipo $\gamma$.
Esto se chequea de acuerdo a qué regla de tipo quiere aplicar el usuario.
Por lo tanto, el lambda término final es de la forma: $t = (t_{1} \; . \; t_{2} \dots t_{n-2} \; . \; t_{n-1}) \; t_{n}$, donde $t_{n}$ es un lambda término no vació, que sirve de argumento a la composiciones
de funciones. Cada $t_{i}$, con $i \in \{ 1 \dots n \}$, se corresponde con una regla de tipado, que a su vez se corresponde con una regla de deducción natural, 
que da el usuario.

Nuestro asistente debería preservar el siguiente invariante. 

\begin{invariant}
Sea $t$ el tipo objetivo de un contexto $\Gamma$ en una subprueba $i$. 

Luego, $fv(t) \; \cap \; bv(t) \; \cap \; vars(\Gamma) \; \cap \; lam \; \cap \; operadores = \emptyset$.
Donde, $vars(\Gamma)$ es conjunto de todas las variables que componen el contexto,
por ejemplo $vars(\{a,b,H0:a\})= {a,b,H0}$. Luego, $lam$ es el conjunto de nombres de los lambda términos definidos hasta
la subprueba $i$. Mientras que, $operadores$ es el conjunto de nombres de todos los operadores definidos hasta la subprueba $i$.  
\end{invariant}

Cuando se ingresa un tipo o fórmula, posiblemente se lo renombre, de modo tal de que éste respete el invariante.
Esta convención nos permite evitar la captura de variables, pues si \textit{t} es un tipo, entonces no se declaran 
dos variables de tipo ligadas con el mismo nombre, una más anidada que la otra.

\subsection{Ejemplos}
\label{ejemplos}

Una subprueba se corresponde a un nodo en el árbol de derivación. 
Las tácticas que ingresa el usuario construyen dicho árbol. Cuando se demuestran todas las subpruebas, se obtiene el lambda término final. 

Podemos ver en la Figura \ref{Estados} un diagrama compuesto de todas las subpruebas que se generan al demostrar el
siguiente secuente:
$p, \; q \vee  (p \rightarrow t) \rightarrow  r, \; t, \; p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w \vdash w$.

Empleamos la siguiente notación:\\

\tikz \node[rectangle,draw,label=below:
Estado de $subps$]{Subpruebas};

Donde, $subps$\footnote{Campo del datatype \texttt{ProofConstruction}, en \texttt{Proof.hs}.} mantiene los datos de las subpruebas, 
y $ty$\footnote{Campo del datatype \texttt{SubProof}, en \texttt{Proof.hs}.} retorna el objetivo de la subprueba que recibe como
argumento.
La transición de un estado a otro se realiza mediante una táctica.
Consideramos $C = H0 : p, \; H1 : q \vee  (p \rightarrow t) \rightarrow  r, \; H2 : t, \; H3: p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w$.

\begin{figure}  
  \begin{tikzpicture}[->, node distance=2cm, auto, thick,main node/.style={rectangle,draw}]

    \node[main node, label={[align=left]below:$subps = [s_{0}]$\\$\wedge \; ty \; s_{0} = [w]$}] (1) {$C \vdash  w$};
    \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\ $\wedge \; ty \; s_{1} = [p \wedge q]$ \\ 
      $\wedge \; ty \; s_{0} = [r, q \vee t]$}] 
    (2) [right=of 1] {$C \vdash  p \wedge t$, $C \vdash r$, $C \vdash q \vee t$};
    \begin{scope}[node distance=1.4cm]
      \node[main node, label={[align=left]below:$subps = [s_{2},s_{1},s_{0}]$\\$\wedge \; ty \; s_{2} = [p]$
        \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}]
      (3) [right=of 2] {$C \vdash  p , C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=1cm]
      \coordinate [right=of 3] (4) {};
    \end{scope}
    \begin{scope}[node distance=2.8cm]
      \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}] 
      (5) [below=of 4] {$C \vdash t$, $C \vdash r$,$C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=2.2cm]
      \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [r]$ \\ $\wedge \; ty \; s_{0} = [q \vee t]$}] 
      (6) [left=of 5] {$C \vdash r$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=1.7cm]
    \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [q \vee  (p \rightarrow t)]$ \\ 
      $\wedge \; ty \; s_{0} = [q \vee t]$}] 
    (7) [left=of 6] {$C \vdash q \vee  (p \rightarrow t)$, $C \vdash q \vee t$};
    \coordinate [left=of 7] (8) {};
    \end{scope}
    \begin{scope}[node distance=2.8cm]
      \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [p \rightarrow t]$ \\ $\wedge \; ty 
        \; s_{0} = [q \vee t]$}] 
      (9) [below=of 8] {$C \vdash p \rightarrow t$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=1.5cm]
      \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [t]$ \\ $\wedge \; ty 
        \; s_{0} = [q \vee t]$}] 
      (10) [right=of 9] {$\{C, H4: p \}\vdash t$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=2.4cm]
      \node[main node, label={[align=left]below:$subps = [s_{0}]$ \\ $\wedge \; ty \; s_{0} = [q \vee t]$}] 
      (11) [right=of 10] {$C \vdash q \vee t$};
      \coordinate [right=of 11] (12) {};
      \node[main node, label={[align=left]below:$subps = [s_{0}]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
      (13) [below=of 12] {$C \vdash t$};
      \node[main node, label={[align=left]below:$subps = [\;]$}] 
      (14) [left=of 13] {$\emptyset$};
    \end{scope}
    \path[draw] (1) edge [above] node {\texttt{apply H3}} (2) (2) edge [above] node {\texttt{split}} (3)
    (3) -- (4) (4) edge node [left] {\texttt{assumption}} (5) (5) edge node [above] {\texttt{assumption}} (6) 
    (6) edge node [above] {\texttt{apply H1}} (7) (7) -- (8) (8) -- node [right] {\texttt{right}} (9)
    (9) edge node [above] {\texttt{intro}} (10) (10) edge node [above] {\texttt{assumption}} (11)
    (11) -- (12) (12) -- node [left] {\texttt{right}} (13) (13) edge node [above] {\texttt{assumption}} (14);
  \end{tikzpicture}
  \caption{Diagrama de subpruebas. Secuente: 
$p, \; q \vee  (p \rightarrow t) \rightarrow  r, \; t, \; p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w \vdash w$.
} \label{Estados}
\end{figure}

\begin{table}[]
\centering
\caption{Prueba de $\forall p, \forall q, p \wedge q \rightarrow p$}
\label{Ejemplo}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Tácticas} & \textbf{Lambda término} & \textbf{Derivación} \\ \hline
  \texttt{-}    &     ?          & \AxiomC{}
                            \UnaryInfC{$\forall p, \forall q, p \wedge q \rightarrow p$}
                            \DisplayProof   \\ \hline
  \texttt{intros} & $\lambda p. \lambda q. \lambda H0: p \wedge q. \; ?$ 
                          & \AxiomC{$$}
                            \noLine
                            \UnaryInfC{$p$}
                            \noLine
                            \UnaryInfC{$q$}
                            \noLine
                            \UnaryInfC{$H0: p \wedge q$}
                            \UnaryInfC{$p$}
                            \DisplayProof   \\ \hline
 \texttt{intros; elim H0} 
         & $\lambda p. \lambda q. \lambda H0: p \wedge q. \; elim\_and \; [p] \; [q] \; [p] \; H0 \; ?$
                          & \AxiomC{$$}
                            \noLine
                            \UnaryInfC{$p$}
                            \noLine 
                            \UnaryInfC{$q$}
                            \noLine
                            \UnaryInfC{$H0: p \wedge q$}
                            \UnaryInfC{$p \rightarrow q \rightarrow p$}
                            \DisplayProof   \\ \hline
 \texttt{intros; elim H0; intros}
         & \begin{tabular}[c]{@{}c@{}}$\lambda p. \lambda q. \lambda H0: p \wedge q. \; elim\_and \; [p] \; [q] \; [p]$
             \\ $H0 \; (\lambda H1: p. \lambda H2: q. \; ?)$\end{tabular}
                          & \AxiomC{$$}
                            \noLine
                            \UnaryInfC{$p$}
                            \noLine 
                            \UnaryInfC{$q$}
                            \noLine
                            \UnaryInfC{$H0: p \wedge q$}
                            \noLine
                            \UnaryInfC{$H1: p$}
                            \noLine
                            \UnaryInfC{$H2: q$}
                            \UnaryInfC{$p$}
                            \DisplayProof   \\ \hline
  \begin{tabular}[c]{@{}c@{}}\texttt{intros; elim H0}\\ \texttt{intros; assumption}\end{tabular}
         & \begin{tabular}[c]{@{}c@{}}$\lambda p. \lambda q. \lambda H0: p \wedge q. \; elim\_and \; [p] \; [q] \; [p]$
             \\ $H0 \; (\lambda H1: p. \; \lambda H2: q. \; H1)$\end{tabular}
                          & - \\ \hline

\end{tabular}
\end{table}

En la construcción del lambda término, utilizamos \textit{términos con agujeros}, de modo tal que sucesivas aplicaciones 
de las tácticas armen el término que cumpla con el tipo deseado.

Tomemos como ejemplo la siguiente fórmula: $\forall p, \forall q, p \wedge q \rightarrow p$.
Lo probaremos aplicando reglas de eliminación e introducción mediante el uso de tácticas.

En el Cuadro \ref{Ejemplo}, vemos una prueba del teorema.
La columna \textbf{Tácticas} muestra las tácticas ingresadas. 
La columna \textbf{Lambda término} tiene el lambda término asociado a la prueba, 
y por último \textbf{Derivación} indica la derivación que resta probar una vez procesadas las tácticas.
Vemos que la aplicación de cada táctica corresponde a un lambda término.
Una vez finalizada la prueba, se tiene un lambda término completo.

\section{Comandos}

El asistente de prueba cuenta con un entorno global\footnote{Se representa mediante el datatype \texttt{GlobalState}, 
en \texttt{GlobalState.hs}.}, el cual llamaremos $GEnv$.
En este entorno están las variables declaradas.

\begin{verbatim}
> Variables a, b;
\end{verbatim}

Se añaden $a$ y $b$ a $GEnv$. El contexto con el cual inicia una prueba tendrá a las variables $a$ y $b$.

Además, $GEnv$ tiene los teoremas probados.

\begin{verbatim}
> Theorem t1: a -> a;
\end{verbatim}
  
El contexto inicial es $\Gamma_1 = a, \; b$. 

\begin{verbatim}
a1 < intro; assumption;
\end{verbatim}

Cuando la prueba termina se añade a $GEnv$ el nombre del teorema, el tipo, y
la prueba: $t1$, $a \rightarrow a$, $\lambda H0:a. \; H0$.
Luego,  $t1$ puede utilizarse en pruebas posteriores.

En $GEnv$ están los supuestos.

\begin{verbatim}
> Axiom a1: forall p, p \/ ~p;
\end{verbatim}

Se añaden el nombre y el tipo a $GEnv$, es decir, $a1$ y $\forall p, p \vee \neg p$.
De este modo, $a1$ estará disponibles en las siguientes pruebas.

Por último, en $GEnv$ están los operados definidos por el usuario.

\begin{verbatim}
> x $ y  = ~x -> ~y;
\end{verbatim}

El contexto con el cual inicia cada prueba se obtiene de $GEnv$. Cuando inicia el asistente, $GEnv$ tiene los lambda términos
y operadores definidos en \texttt{Prelude.pr}.

Estos son los comandos que definen el lenguaje del asistente de prueba.

\begin{itemize}

\item \texttt{Variables} \textit{var}. Declaración de variables.
\item \textit{name} \texttt{=} \textit{type}. Declaración de un operador.
  Permite definir sinónimos de tipos. 

  Variantes:
  \begin{itemize}
  \item \textit{name}/\textit{symbol} $var_1$ \ldots $var_n$ \texttt{=} \textit{type}.
    Define al operador \textit{name} (o \textit{symbol}) de manera prefija. 
    % Es equivalente a escribir:
    % \textit{name} \texttt{=} $\forall \; var_0, \; \ldots \; , \forall var_n, \; type$.
  \item $var_1$ \textit{symbol} $var_2$. Define al operador \textit{symbol} de manera infija.

    % Es equivalente a escribir:
    % \textit{name} \texttt{=} $\forall \; var_0, \forall var_1, \; type$.
  \end{itemize}

\item \textit{name} \texttt{=} \textit{lambda term}. Declaración de un lambda término,
se lo añade al entorno global.

\item \textit{name} \texttt{:} \textit{type}. Declaración del nombre de un lambda término. 
Se lo añade al entorno global. Equivale a \texttt{Axiom} \textit{name} \texttt{:} \textit{type}.

\item \texttt{Theorem} \textit{name} \texttt{:} \textit{type}. Inicia la prueba de un
teorema. Cuando la prueba finaliza, añade el lambda término asociado a la prueba al entorno global.
Equivale a \textit{name} \texttt{=} \textit{proof}.


\item \texttt{Axiom} \textit{name} \texttt{:} \textit{type}. Asume \textit{type} como un postulado.
Equivale a \textit{name} \texttt{:} \textit{type}.

\item \texttt{Print} \textit{name}. Imprime en pantalla la prueba de \textit{name}, si existe.

Variante:
\texttt{Print} \_. Imprime todo el entorno (operadores, términos declarados).

\item \texttt{Check} \textit{lambda term}. Determina el tipo de \textit{lambda term}, si existe.

\item \textit{tactic}. Tácticas, ver sección \ref{tácticas}.

\end{itemize}

Comandos de control: 

\begin{itemize}

\item \texttt{:load} \textit{proof files}. Carga desde uno o varios archivos que tengan sufijo \texttt{``.pr''}.

\item \texttt{:save} \textit{proof file}. Guarda en un archivo (que tenga sufijo \texttt{``.pr''}) todos los comandos válidos ingresados hasta ese momento.

\item \texttt{:abort}. Cancela la prueba actual.

\item \texttt{:quit}. Sale del asistente de prueba.

\item \texttt{:help}. Imprime un mensaje describiendo todos los comandos.

\end{itemize}

Consideramos que tanto $var$ como $name$, representan una palabra alfanumérica, mientras
que $symbol$ sigue la definición dada en la sección \ref{gramáticas}. 

Es posible escribir varios comandos en la misma entrada,
incluso comandos $incompletos$. Es decir que podemos ir completando el comando. 
Por ejemplo,

\begin{verbatim}
> Theorem 
>* t2 : forall q,
>* q -> q;
\end{verbatim}

Todos los comandos $completos$, que no son de control, deben terminar con punto y coma \texttt{``;''}. 

\subsection{Tácticas}
\label{tácticas}

A continuación se describen las tácticas de acuerdo a las reglas de inferencias.

\begin{itemize}
\item Caso trivial: táctica \texttt{assumption}, o \texttt{apply} $H$.   
  
  \AxiomC{$\Gamma$}
  \noLine
  \UnaryInfC{$H:\alpha$}
  \UnaryInfC{$\alpha$}
  \DisplayProof

Corresponde al término $\mathtt{H}$.

\item Introducción de la implicancia: táctica \texttt{intro}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \rightarrow \beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $\mathtt{\lambda H:\alpha. \; ?_{1}}$, siendo
  $?_{1}$ la prueba de $\beta$.

\item Introducción del para todo: táctica \texttt{intro}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\forall x, \; \beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$x$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $\mathtt{\lambda x. \; ?_{1}}$, donde $?_{1}$ es la prueba de $\beta$.

\item Introducción de la disyunción izquierda: táctica \texttt{left}.
  
  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \vee \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}

Corresponde al término $\mathtt{(intro\_or1 \; [\alpha] \; [\beta] \; ?_{1})}$, siendo $?_{1}$ la prueba de $\alpha$.

\item Introducción de la disyunción derecha: táctica \texttt{right}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \vee \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}
  
  Corresponde al término $\mathtt{(intro\_or2 \; [\alpha] \; [\beta] \; ?_{1})}$, donde $?_{1}$ es la prueba de $\beta$.

\item Introducción de la conjunción: táctica \texttt{split}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \wedge \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $\mathtt{(intro\_and \; [\alpha] \; [\beta] \; ?_{1} \; ?_{2})}$, 
  donde $?_{1}$ es la prueba de $\alpha$, y $?_{2}$ es la prueba de $\beta$.

\item Introducción del existencial: táctica \texttt{exists $\alpha$}.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\exists \; x, \; \sigma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\sigma [x \rightarrow \alpha]$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término ($\mathtt{\{ ^*\alpha, ?_1 \} \; as \; exists \; x, \; \sigma}$), 
  siendo $?_{1}$ la prueba de $\mathtt{\sigma [x \rightarrow \alpha]}$. 

\item Introducción del absurdo: táctica \texttt{absurd $\alpha$}. 

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$False$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\neg \alpha$}
    \DisplayProof    
  \end{minipage}

  Corresponde a la prueba $\mathtt{(intro\_bottom \; [\alpha] \; ?_{1} \; ?_{2})}$, siendo $?_{1}$ la prueba de $\alpha$, 
  y $?_{2}$ la prueba de $\neg \alpha$.

\item Eliminación de la implicancia: táctica \texttt{apply} $H$.

  \begin{minipage}[t]{0.18\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H:\alpha \rightarrow \beta$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \rightarrow \beta$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}

  Corresponde a la prueba $\mathtt{(H \; ?_{1})}$, donde $?_{1}$ es la prueba de $\alpha$.

  La táctica también se puede aplicar en la siguiente situación:

  \begin{minipage}[t]{0.35\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H:\alpha_{1} \rightarrow \alpha_{2} \rightarrow \ldots \rightarrow \alpha_{n} \rightarrow \beta$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.07\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \ldots$}
    \UnaryInfC{$\alpha_{1}$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \ldots$}
    \UnaryInfC{$\alpha_{2}$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.04\linewidth}
    \ldots    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \ldots$}
    \UnaryInfC{$\alpha_{n}$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $\mathtt{(H \; ?_{1} \; \ldots \; ?_{n})}$, donde $?_{i}$ es la prueba de $\alpha_{i}$.

\item Eliminación del para todo: táctica \texttt{apply} $H$.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \forall x, \; \beta$}
    \UnaryInfC{$\gamma$}
    \DisplayProof
  \end{minipage}

  Corresponde al término $\mathtt{(H \; [\theta])}$, si existe $\theta$ tal que $\mathtt{\gamma = \beta[x \rightarrow \theta]}$.
  
  En términos generales,

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \forall x_{1}, \forall x_{2}, \ldots ,\forall x_{n}, \; \beta$}
    \UnaryInfC{$\gamma$}
    \DisplayProof
  \end{minipage}

  Corresponde a la prueba $\mathtt{(H \; [\theta_{1}] [\theta_{2}] \ldots [\theta_{n}])}$,
  de modo tal que $\mathtt{\gamma = \beta \; [ x_{1} \rightarrow \theta_{1} ] \ldots [x_{n} \rightarrow \theta_{n}]}$, 
  si existen $\theta_{1} \ldots \theta_{n}$.

\item Eliminación de la disyunción: táctica \texttt{elim} $H$.

  \begin{minipage}[t]{0.18\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \vee \beta$}
    \UnaryInfC{$\sigma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.15\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \vee \beta$}
    \UnaryInfC{$\alpha \rightarrow \sigma$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \vee \beta$}
    \UnaryInfC{$\beta \rightarrow \alpha$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $\mathtt{(elim\_or \; [\alpha] \; [\beta] \; [\sigma] \; H \; ?_{1} \; ?_{2})}$, 
  donde $?_{1}$ es la prueba de $\alpha \rightarrow \sigma$, y $?_{2}$ es la prueba de $\beta \rightarrow \alpha$.

\item Eliminación de la conjunción: táctica \texttt{elim} $H$.

  \begin{minipage}[t]{0.18\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \wedge \beta$}
    \UnaryInfC{$\sigma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \wedge \beta$}
    \UnaryInfC{$\alpha \rightarrow \beta \rightarrow \sigma$}
    \DisplayProof    
  \end{minipage}
  
  Corresponde al término $\mathtt{(elim\_and \; [\alpha] \; [\beta] \; [\sigma] \; H \; ?_1)}$, donde $?_{1}$ es la prueba de $\alpha \rightarrow \beta \rightarrow \sigma$.

\item Eliminación del existencial: táctica \texttt{elim} $H$.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \exists \; x, \; \alpha $}
    \UnaryInfC{$\gamma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.05\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \exists \; x, \; \alpha $}
    \noLine
    \UnaryInfC{$x$}
    \noLine
    \UnaryInfC{$H' : \alpha$}
    \UnaryInfC{$\gamma$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término ($\mathtt{let \; \{x, H'\} = H \; in \; ?_1}$),
  siendo $?_1$ la prueba de $\gamma$.

\item Eliminación del absurdo: táctica \texttt{elim} $H$.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : False$}
    \UnaryInfC{$\sigma$}
    \DisplayProof
  \end{minipage}

  Corresponde al término $\mathtt{(elim\_bottom \; [\sigma] \; H)}$.

\end{itemize}

Otras tácticas:

\begin{itemize}

\item Lema intermedio: táctica \texttt{cut $\beta$}.

  \begin{minipage}[t]{0.08\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta \rightarrow \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde a la prueba $\mathtt{(?_{1} \; ?_{2})}$, donde $?_1$ es la prueba de $\beta \rightarrow \alpha$, y $?_2$ es la
  prueba de $\beta$.

\item Explicitación de la prueba: táctica \texttt{exact} $lamt$, donde $lamt$ es un lambda término.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof
  \end{minipage}

  Termina la prueba, si $lamt : \alpha$.
  
\item Explicitación de la fórmula: táctica \texttt{exact} $ty$, donde $ty$ es un tipo.

  Cuando el algoritmo de unificación no puede decidir el tipo a unificar, se deja a criterio del usuario resolverla,
  mediante la táctica \texttt{exact}. Por ejemplo,

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \forall x, \forall y, y \rightarrow y$}
    \UnaryInfC{$a \rightarrow a$}
    \DisplayProof

  \end{minipage}

  Vemos que $x$ puede unificar con cualquier tipo.

\item Eliminación de la definición: táctica \texttt{unfold} $op$, donde $op$ es un operador.

  Aplica la definición del operador \textit{op}. Por ejemplo, \texttt{unfold not} produce lo siguiente,

  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\neg \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \rightarrow False$}
    \DisplayProof    
  \end{minipage}
  
  Es posible usar \texttt{unfold} en las hipótesis así: \texttt{unfold} $op$ \texttt{in} $H$, donde $H$ es el nombre de la hipótesis.

\item Introducción de la implicación y del para todo: táctica \texttt{intros}.
  Esta táctica aplica \texttt{intro} hasta que no se pueda seguir aplicando.

\end{itemize}


\section{Módulos}

A continuación se describe brevemente cuales son los aspectos fundamentales que trata cada módulo.

\begin{itemize}

\item \texttt{ErrorMsj}: pretty printer de los mensajes de error.
\item \texttt{Common}: contiene los $AST$ principales.
\item \texttt{Proof}: oculta las funciones que operan sobre la construcción de una prueba.
\item \texttt{GlobalState}: tiene funciones que operan sobre datos ``globales'', es decir que son
datos que se mantienen durante toda la ejecución del asistente.
\item \texttt{ProverState}: mantiene el estado general del asistente, incluye los datos de la
construcción de una prueba y los datos globales.
\item \texttt{TypeSubstitution}: oculta el algoritmo de substitución.
\item \texttt{TypeUnification}: oculta la unificación de tipos.
\item \texttt{TypeInference}: oculta la inferencia de tipos.
\item \texttt{TypeDefinition}: contiene funciones que operan sobre el entorno de tipos.
\item \texttt{LambdaTermDefinition}: tiene funciones que operan sobre el entorno de los lambda términos.
\item \texttt{TermsWithHoles}: oculta el tratamiento de los lambda términos con agujeros o vacíos.
\item \texttt{Hyphotesis}: tiene funciones relacionadas con las hipótesis.
\item \texttt{RenamedVariables}: oculta el algoritmo de renombramiento utilizado sobre los nombres de la hipótesis.
\item \texttt{Transformers}: mantiene las transformaciones de lambda términos y tipos.
\item \texttt{Tactics}: se encarga de construir una prueba a partir de una táctica.
\item \texttt{PrettyPrinter}: pretty printer general del asistente.
\item \texttt{Parser}: parser del lenguaje.
\item \texttt{Main}: proceso de la entrada y la salida. 
\item \texttt{PreludePath}: oculta la ubicación del archivo \texttt{Prelude.pr}.

\end{itemize}


\section{Gramáticas}
\label{gramáticas}
Veremos algunas de las gramáticas más importantes del lenguaje.
Gramática del lambda calculo:

\begin{tabbing}
$\langle lamTerm \rangle$ \hspace{0.5cm} \= $::=$ $\langle abs \rangle$ | $\langle app \rangle$ 
\Big( $\langle abs \rangle$ | $\varepsilon$ \Big) \\

$\langle app \rangle$ \> $::=$ $\langle app \rangle$ $\Big($ \texttt{'['} $\langle typeTerm \rangle$ \texttt{']'} 
| $\langle unitTerm \rangle \; \Big)$ 
| $\langle unitTerm \rangle$ \\

$\langle unitTerm \rangle$ \> $::=$ $\langle unitaryTerm \rangle$ $\Big($ \texttt{'as'} $\langle typeTerm \rangle \; 
| \; \varepsilon \; \Big)$ \\

$\langle unitaryTerm \rangle$ \> $::=$ \texttt{'('} $\langle lamTerm \rangle$ \texttt{')'} 
| $\langle var \rangle$ \\

$\langle abs \rangle$ \> $::=$ \texttt{'$\lambda$'} $\langle var \rangle$ $\Big($ \texttt{':'} $\langle typeTerm \rangle$ \texttt{'.'} 
$\langle lamTerm \rangle$ | \texttt{'.'} $\langle lamTerm \rangle \; \Big)$ \\
\> | \texttt{'\{' '*'} $\langle typeTerm \rangle$ \texttt{','} $\langle lamTerm \rangle$ \texttt{'\}' 'as'} $\langle typeTerm \rangle$ \\
\> | \texttt{'let' '\{'} $\langle var \rangle$ \texttt{','} $\langle var \rangle$ \texttt{'\}' '='} $\langle lamTerm \rangle$ \texttt{'in'}
$\langle lamTerm \rangle$

\end{tabbing}

Consideramos a $\langle var \rangle$, como la gramática de palabras alfanuméricas, (incluido el guión bajo) 
exceptuando las palabras reservadas: \texttt{Theorem}, \texttt{forall}, \texttt{False}, etc.

Gramática de fórmulas o tipos:

\begin{tabbing}

$\langle typeTerm \rangle$ \hspace{0.3cm} \= $::=$ $\langle unit_{1} \rangle$ $\Big($ \texttt{'<->'} $\langle typeTerm \rangle$ | $\varepsilon \; \Big)$\\
$\langle unit_{1} \rangle$ \> $::=$ $\langle unit_{2} \rangle$ $\Big($ \texttt{'->'} $\langle unit_{1} \rangle$ | $\varepsilon$ $\Big)$ \\
$\langle unit_{2} \rangle$ \> $::=$ $\langle unit_{3} \rangle$ $\Big($ \texttt{'\textbackslash/'} $\langle unit_{2} \rangle$ 
| $\varepsilon$ $\Big)$ \\
$\langle unit_{3} \rangle$ \> $::=$ $\langle infixOps \rangle$ $\Big($ \texttt{'/\textbackslash'} $\langle unit_{3} \rangle$ 
| $\varepsilon$ $\Big)$ \\
$\langle unit_{4} \rangle$ \> $::=$ \texttt{'$\sim$'} $\langle unit_{4} \rangle$ 
| $\langle prefixOps \rangle$ | $\langle unit_{5} \rangle$ | $\langle quantifiers \rangle$\\
$\langle unit_{5} \rangle$ \> $::=$ \texttt{'('} $\langle typeTerm \rangle$ \texttt{')'} | \texttt{False} | $\langle var \rangle$  \\
$\langle infixOps \rangle$ \> $::=$ $\langle unit_{4} \rangle$ $\Big($ $\langle symbol \rangle$ $\langle infixOps \rangle$ $\Big)$ 
| $\varepsilon$\\
$\langle prefixOps \rangle$ \> $::=$ $\langle prefixOps \rangle$ $\langle unit_{5} \rangle$ | $\langle app \rangle$\\
$\langle app \rangle$ \> $::=$ \texttt{'('} $\langle prefixOps \rangle$ \texttt{')'} | $\langle symbol \rangle$ | $\langle var \rangle$ \\
$\langle quantifiers \rangle$ \> $::=$ $\Big($ \texttt{'forall'} | \texttt{'exists'} $\Big)$ $\langle var \rangle$ \texttt{','} $\langle typeTerm \rangle$ \\
\end{tabbing}

Tenemos que $\langle symbol \rangle$ es la gramática de símbolos, mas precisamente se tratan de caracteres de símbolos Unicode, 
incluye símbolos matemáticos, de moneda y los caracteres \texttt{\textbackslash}, \texttt{/}, y \texttt{-}, exceptuando a los
símbolos: \texttt{\textbackslash/}, \texttt{/\textbackslash}, etc.

Precedencia de los operadores:

\setlist[enumerate,1]{start=0}
\begin{enumerate}

\item \textit{Prefix operators}, $\mathtt{\sim}$
\item \textit{Binary infix operators}
\item \texttt{/\textbackslash}
\item \texttt{\textbackslash/}
\item \texttt{->}
\item \texttt{<->}
\item \texttt{forall}, \texttt{exists} 

\end{enumerate}

Los operadores con un valor de precedencia alto tienen menos precedencia que otro con un valor más bajo.
Por ejemplo, \texttt{/\textbackslash} tiene más precedencia que \texttt{\textbackslash/}.

Consideramos a \textit{Prefix operators} como el conjunto de los todos los operadores prefijos definidos por el usuario,
donde todos ellos tienen la misma precedencia.
Mientras que \textit{Binary infix operators} es el conjunto de los operadores binarios infijos dados por el usuario,
todos mantienen la misma precedencia.

Todos los operadores binarios infijos asocian a derecha.

% Cuando implementamos el comando \texttt{unfold}, nos aseguramos que el tipo resultado de la sustitución, respete la \textbf{Convención 1}.
% Además, sabemos que en el entorno de variables de tipos no se tiene la misma variable más de dos veces, gracias al renombramiento.
% Por ello, al aplicar la táctica \texttt{intro} sobre un ``para todo'', no es necesario chequear que no la variable de tipo ligada
% no se encuentre en el contexto de tipos, pues ya sabemos que no está allí, gracias al renombramiento de variables de tipos ligadas.

% En la implementación de la regla de tipado, correspondiente a la introducción del existe, consideramos que $t_{2}$ debe tener un tipo equivalente
% a $T_{2}[X:=U]$, llamemos lo $T$. Es decir que $T$ puede variar de $T_{2}[X:=U]$, con respecto a los nombres de las variables de tipo ligadas que aparecen en 
% el segundo.
% Hacemos esto para respetar la \textbf{Convención 1}. 
  
% El tipo $T$ lo calcula la función \texttt{applyTypes}. Para ello, realiza la sustitución $T_{2}[X:=U]$, más un renombramiento que respete la \textbf{Convención 1}.
% Ver Ejemplo 7, en los casos de inferencia OK.

% Consideramos dos espacios de nombres para las variables.
% \begin{itemize}j
% \item $v.términos = v.ligadas_{te} \cup v.libres_{te}$
% \item $v.libres_{te} = teoremas$
% \item $v.tipos = v.ligadas_{ti} \cup v.libres_{ti}$
% \item $v.libres_{ti} = proposiciones \cup operadores$
% \end{itemize}

% Donde, $v.ligadas_{ti} \cap v.libres_{ti} = \emptyset$, para satisfacer la \textbf{Convención 1}.
% Además, $v.libres_{te} \cap v.libres_{ti} = \emptyset$, para desambiguar las aplicaciones de variables.

% También, consideramos para cada prueba, $hipótesis \cap teoremas = \emptyset$. De lo contrario, tendríamos conflictos de nombres.


\begin{thebibliography}{9}
\bibitem{pierce} 
  Benjamin C. Pierce. 
  Types and Programming Languages. 2002.

\bibitem{languageEng}
  Ana Bove, Luís Soares Barbosa,
  Alberto Pardo, y
  Jorge Sousa Pinto.
  Language Engineering and Rigorous Software Development.
  Springer, 2009.

\bibitem{curry-howard}
  Morten Heine Sørensen, y Pawel Urzyczyn.
  Lectures on the Curry-Howard Isomorphism.
  2006

\end{thebibliography}


\end{document}
