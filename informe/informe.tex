\documentclass[a4paper,11pt]{article}
\usepackage[left=1.5cm,top=2.0cm,right=1.5cm,bottom=2.0cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern,bm}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{bussproofs}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage{amsthm}

\newtheorem{theorem}{Teorema}
\theoremstyle{definition}
\newtheorem{definition}{Definición}

\usetikzlibrary{positioning, babel,shapes}
\newdimen\nodeDist
\nodeDist=35mm

\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{}
\author{}

\begin{document}

\maketitle 

\begin{center}
\section*{Análisis de lenguajes de programación} 
\subsection*{Asistente de prueba de la lógica proposicional constructiva de segundo orden}
\end{center}

\newpage{\pagestyle{empty}\cleardoublepage}


\section{Motivación}
Era de especial intereses para el autor entender la cual es la relación entre la lógica y el lambda cálculo.
Para ello decide implementar un asistente de prueba, el cual emplea la correspondencia
existente entre el Sistema F, y la lógica proposicional constructiva de segundo orden.
 
\section{Fórmulas como tipos}
Podemos interpretar $M : \sigma$ de dos formas:
\begin{itemize}
  \item Término como programa, tipo como especificación: $M$ es una función de tipo $\sigma$.
  \item Tipo como una fórmula, término como su prueba: $M$ es una prueba de la fórmula $\sigma$.
\end{itemize}

La correspondencia Curry-Howard fórmulas como tipos, es una correspondencia uno a uno entre términos
tipados del lambda cálculo y las derivaciones en la lógica proposicional minimal.
Desde el punto de vista de la lógica: $x_{1}:\tau_{1}, x_{2}:\tau_{2}, \ldots, x_{n}:\tau_{n} \vdash M : \sigma$,
puede leerse como $M$ es una prueba de $\sigma$ a partir de las hipótesis $\tau_{1}, \tau_{2}, \ldots, \tau_{n}$.  
 


\begin{definition}
El sistema de lógica proposicional PROP restringido al conectivo de implicación se define de la siguiente manera.

\begin{itemize}
  \item Sintaxis abstracta:
  
  $prop ::= PropVar \; | \; (prop \rightarrow prop)$.
  
  \item Reglas de derivación. Donde $\Delta$ es un conjunto de proposiciones, $\sigma$ y $\tau$ son proposiciones.
    
    \begin{minipage}[t]{0.3\linewidth}
      \centering
      \begin{prooftree}
        \AxiomC{$\sigma \in \Delta$}
        \UnaryInfC{$\Delta \vdash \sigma$}
      \end{prooftree}
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      \centering

      \begin{prooftree}
        \AxiomC{$\sigma \rightarrow \tau \hspace{0.5cm} \sigma$}
        \RightLabel{\scriptsize \textsc{E-$\rightarrow$}}
        \UnaryInfC{$\tau$}
      \end{prooftree}
      
    \end{minipage}
    \begin{minipage}[t]{0.3\linewidth}
      \centering
      \begin{prooftree}
        \AxiomC{ $[\sigma]^{j}$}
        \noLine
        \UnaryInfC{$\vdots$}
        \noLine
        \UnaryInfC{$\tau$}        
        \RightLabel{\scriptsize \textsc{I-$\rightarrow^{[j]}$}}
        \UnaryInfC{$\sigma \rightarrow \tau$}
      \end{prooftree}
      
    \end{minipage}
   
\end{itemize}

Decimos que $\Delta \vdash_{Prop} \sigma$ si existe una derivación usando las reglas, con conclusión $\sigma$ y hipótesis en $\Delta$.
\end{definition}

Procedemos a definir lo que entendemos por fórmulas como tipos. Para ello consideramos al contexto en PROP como listas
($\Delta$ es una lista en la siguiente definición).


\begin{definition}
  La noción de prueba como término, es decir, derivaciones de PROP a términos del lambda cálculo simplemente tipado $\lambda_{\rightarrow}$, 
  se define inductivamente como sigue.

  Asociamos a las listas de proposiciones $\Delta$ un contexto $\Gamma$, en donde se reemplaza $\sigma$ en $\Delta$ con $x_{i} : \sigma_{i} \in \Gamma$.
  Del lado izquierdo vemos la clausula inductiva de la derivación y en el lado derecho, se describe del lado superior a la línea,
  los términos que tenemos por inducción, y debajo, el término asociado a la derivación.

  \vspace{0.5cm}

  \begin{minipage}[t]{0.4\linewidth}
    \centering

    \begin{prooftree}
      \AxiomC{$\sigma \in \Delta$}
      \UnaryInfC{$\Delta \vdash \sigma$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\sigma \rightarrow \tau \hspace{0.5cm} \sigma$}
      \UnaryInfC{$\tau$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC { $[\sigma]^{j}$}
      \noLine
      \UnaryInfC{$\vdots$}
      \noLine
      \UnaryInfC{$\tau$}        
      \UnaryInfC{$\sigma \rightarrow \tau$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}
    \centering

    \begin{prooftree}  
      \AxiomC{$x : \sigma \in \Delta$}
      \UnaryInfC{$\Gamma \vdash x : \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma_{1} \vdash M : \sigma \rightarrow \tau$}
      \AxiomC{$\Gamma_{2} \vdash N : \sigma$}
      \BinaryInfC{$\Gamma_{1} \cup \Gamma_{2} \vdash M \; N : \tau$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma,x:\sigma \vdash M : \tau$}
      \UnaryInfC{$\Gamma \vdash \lambda x : \sigma. \; M : \sigma \rightarrow \tau$}
    \end{prooftree}

  \end{minipage}

  \vspace{0.5cm}

  Si $\mathcal{D}$ es una derivación en PROP, entonces $\overline{\mathcal{D}}$ es un lambda término en $\lambda_{\rightarrow}$.
\end{definition}


\begin{theorem}
  Soundness, Completitud de formulas como tipos.

  \begin{enumerate}
  \item Si $\mathcal{D}$ es una deducción natural en PROP con conclusión $\sigma$ y hipótesis en $\Delta$, entonces
    $\bm{x}:\bm{\Delta} \vdash \overline{\mathcal{D}} : \sigma$, en $\lambda_{\rightarrow}$.
  \item Si $\Gamma \vdash M : \sigma$ en $\lambda_{\rightarrow}$, entonces hay una derivación de $\sigma$ desde $\Delta$ en PROP,
    donde $\Delta$ es $\Gamma$ sin la asignación de variables.
  \end{enumerate}

\end{theorem}

La correspondencia fórmulas como tipos constituye un isomorfismo entre derivaciones en PROP y términos bien formados en $\lambda_{\rightarrow}$.
Dicho de otra manera, una fórmula es teorema si y solo si es un tipo habitado.

\subsection{Lambda cálculo con polimorfismo}
\label{Lambda cálculo con polimorfismo}

El lambda cálculo con polimorfismo (Sistema F) sirve como una notación de las pruebas de la lógica proposicional constructiva
de segundo orden.
Comenzamos definiendo al Sistema F.

\begin{definition}
  Los tipos del Sistema F, estilo Church, son:

  $Typ := TVar \; | \; (Typ \rightarrow Typ) \; | \; \forall \alpha . Typ$

  Mientras que las reglas de derivación son :

  \begin{minipage}[t]{0.4\linewidth}
    \centering

    \begin{prooftree}  
      \AxiomC{$x : \sigma \in \Gamma$}
      \UnaryInfC{$\Gamma \vdash x : \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma_{1} \vdash M : \sigma \rightarrow \tau$}
      \AxiomC{$\Gamma_{2} \vdash N : \sigma$}
      \BinaryInfC{$\Gamma_{1} \cup \Gamma_{2} \vdash M \; N : \tau$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma,x:\sigma \vdash M : \tau$}
      \UnaryInfC{$\Gamma \vdash \lambda x : \sigma. \; M : \sigma \rightarrow \tau$}
    \end{prooftree}

  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}

    \begin{prooftree}  
      \AxiomC{$\Gamma \vdash M : \sigma$}
      \RightLabel{$\alpha \notin FV(\Gamma)$}
      \UnaryInfC{$\Gamma \vdash \lambda \alpha. M : \forall \alpha. \sigma$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\Gamma \vdash M : \forall \alpha. \sigma$}
      \UnaryInfC{$\Gamma \vdash : \sigma [ \alpha := \tau]$}
    \end{prooftree}
    
  \end{minipage}
\end{definition}

\begin{figure}
  \centering
  \begin{minipage}[t]{0.35\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Términos: \\
        t \hspace{-0.1cm} ::= x \\ 
        \> $\mathtt {\lambda x : T. \; t}$ \\
        \> t t \\
        \> $\lambda$X. t \\
        \> t [T] \\
        \> \{$^{*}$T, t\} as T \\
        \> let \{X, x\} = t in t \\
        \> t as T
      \end{tabbing} 
    }
  \end{minipage}
  \begin{minipage}[t]{0.3\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Contexto: \\
        $\Gamma$ \hspace{-0.1cm} ::= $\emptyset$ \\
        \> $\Gamma$, x:T \\ 
        \> $\Gamma$, X
      \end{tabbing} 
    }
  \end{minipage}
  \begin{minipage}[t]{0.3\linewidth}
    \texttt{
      \begin{tabbing}
        left \, \= left\kill
        Tipos: \\
        T \hspace{-0.1cm} ::= X \\
        \> T $\rightarrow$ T \\
        \> forall X, T \\
        \> exists X, T 
      \end{tabbing} 
    }
  \end{minipage}

  \texttt{Reglas de tipos}

  \begin{minipage}[t]{0.4\linewidth}
    \centering
    
    \begin{prooftree}  
      \AxiomC{$\mathtt{x : T \in \Gamma}$}
      \RightLabel{\scriptsize \textsc{T-Var}}
      \UnaryInfC{$\mathtt{\Gamma \vdash x : T}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : T_{11} \rightarrow T_{12} \quad \Gamma \vdash t_{2} : T_{11}}$}
      \RightLabel{\scriptsize \textsc{T-App}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} t_{2} : T_{12}}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma, x: T_{1} \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-Abs}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \lambda x: T_{1}. \; t_{2} : T_{1} \rightarrow T_{2}}$}
    \end{prooftree}
    
    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{2} : T_{2} [X \rightarrow U]}$}
      \RightLabel{\scriptsize \textsc{T-Pack}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \{^{*}U, t_{2}\} \; as \; exists \; X,\;  T_{2}}$}
      \noLine
      \UnaryInfC{$\mathtt{: exists \; X,\;  T_{2}}$}
    \end{prooftree}

  \end{minipage}
  \begin{minipage}[t]{0.5\linewidth}
    \centering  

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma, X \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-TAbs}}
      \UnaryInfC{$\mathtt{\Gamma \vdash \lambda X. \; t_{2} : forall \; X, \; T_{2}}$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : forall \; X, \; T_{12}}$}
      \RightLabel{\scriptsize \textsc{T-TApp}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} \; [T_{2}] : T_{12} [X \rightarrow T_{2}]}$}
    \end{prooftree}

    \begin{prooftree}
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : T}$}
      \RightLabel{\scriptsize \textsc{T-Ascribe}}
      \UnaryInfC{$\mathtt{\Gamma \vdash t_{1} \; as \; T : T}$}
    \end{prooftree}

    \begin{prooftree}  
      \AxiomC{$\mathtt{\Gamma \vdash t_{1} : exists \; X, \; T_{12} }$}
      \AxiomC{$\mathtt{\Gamma, X, x:T_{12}  \vdash t_{2} : T_{2}}$}
      \RightLabel{\scriptsize \textsc{T-Unpack}}
      \BinaryInfC{$\mathtt{\Gamma \vdash let \{ X, x \} = t_{1} \; in \; t_{2} : T_{2}}$}
    \end{prooftree}
    
  \end{minipage}
  \caption{Sintaxis y reglas de tipos del Sistema F extendido.}
  \label{SintaxisTiposF}
\end{figure}

Implementamos el Sistema F siguiendo las reglas de inferencia de tipos que presenta Pierce \cite{pierce}.
Ver Figura \ref{SintaxisTiposF}.
Se decidió extenderlo con el inclusión del cuantificador existencial, y la adscripción de un tipo a término.
Era necesario mapear la introducción y eliminación del existencial con un lambda término o regla de inferencia de tipo, 
lo cual puede realizarse de manera directa con la inclusión del cuantificador al lenguaje. 

El sistema F, permite la abstracción tanto de términos como tipos. Con lo cual podemos ``definir'' nuevos
constructores de tipos, a partir del lenguaje, como se muestra a continuación.

\begin{definition}
  Definición de operadores de la lógica intuicionista.

  \begin{itemize}
  \item $\bot := \forall \alpha. \alpha$
  \item $\sigma \wedge \tau := \forall \alpha. (\sigma \rightarrow \tau \rightarrow \alpha) \rightarrow \alpha$
  \item $\sigma \vee \tau := \forall \alpha. (\sigma \rightarrow \alpha) \rightarrow (\tau \rightarrow \alpha) \rightarrow \alpha$
  \item $\neg \alpha := \alpha \rightarrow \bot$
  \item $\alpha \leftrightarrow \beta := (\alpha \rightarrow \beta) \wedge (\beta \rightarrow \alpha)$ 
  \end{itemize}
\end{definition}

A partir de la definición anterior es posible definir las reglas de introducción y eliminación
de los operadores $\bot, \wedge,$ y $\vee$.

Sabemos que es posible describir al existencial de la siguiente manera:
$\exists \alpha. \sigma := \forall \beta. (\forall \alpha. \sigma \rightarrow \beta) \rightarrow \beta$.

Sin embargo, creemos que no es posible dar su regla de introducción y eliminación mediante un lambda término.
Por ello, lo añadimos al lenguaje. Ver Figura \ref{SintaxisTiposF}.


\subsection{Construcción de pruebas}
\label{construcciónDePruebas}

El isomorfismo de Curry-Howard, nos permite relacionar a los tipos con fórmulas lógicas, 
y a las pruebas con lambda términos.

El asistente de prueba implementa el isomorfismo Curry-Howard, se construye un lambda término
a medida que el usuario realiza la prueba de un teorema. 
Cuando se prueba una fórmula $\alpha$, se construye un lambda término $t$, tal que $t:\alpha$.
Es decir, que cuando la prueba finaliza el lambda término asociado a la prueba tendrá como tipo la fórmula probada.

El teorema de Curry-Howard, nos asegura que, si $t:\alpha$, entonces la fórmula asociada a $\alpha$ es válida.

Para probar cierta fórmula objetivo utilizaremos diferentes tácticas que transforman el objetivo original e
introducen hipótesis adicionales.

Cuando construimos una prueba tenemos la siguiente situación:
existen varios objetivos a probar, cada uno a partir de ciertas hipótesis.
\newline

\begin{minipage}[t]{0.1\linewidth}
  \AxiomC{$\Gamma_{1}$}
  \UnaryInfC{$\alpha_{1}$}
  \DisplayProof    
\end{minipage}
\begin{minipage}[t]{0.07\linewidth}
  \AxiomC{$\Gamma_{2}$}
  \UnaryInfC{$\alpha_{2}$}
  \DisplayProof    
\end{minipage}
\begin{minipage}[t]{0.05\linewidth}
  $\ldots$
\end{minipage}
\begin{minipage}[t]{0.1\linewidth}
  \AxiomC{$\Gamma_{n}$}
  \UnaryInfC{$\alpha_{n}$}
  \DisplayProof    
\end{minipage}
\newline

Tenemos que,

\begin{itemize}
\item Cada $\Gamma_{i}$ (contexto) es un conjunto de fórmulas (hipótesis) y variables. donde las hipótesis
son de la forma H0 : $\gamma_{0}$, $\ldots$, Hk : $\gamma_{k}$.
\item $\alpha_{i}$ es una fórmula, la cual debe ser probada a partir de $\Gamma_{i}$. 
\end{itemize}


\begin{figure}[!h]
  \centering
  \begin{tikzpicture}
    %% vertices
    \draw[fill=black] (1,0) circle (3pt);
    \draw[fill=black] (5,1.5) circle (3pt);
    \draw[fill=black] (3,1.5) circle (3pt);
    \draw[fill=black] (5,3) circle (3pt);
    %% vertex labels
    \node at (4.8,3)
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{1}$}
        \UnaryInfC{$\alpha_{1}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (2.7,1.5) 
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{11}$}
        \UnaryInfC{$\alpha_{11}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (4.7,1.5) 
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{12}$}
        \UnaryInfC{$\alpha_{12}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (7,1.5) 
    {
      \ldots
    };
    \node at (0.5,0)
    {
      \begin{minipage}[t]{0.1\linewidth}
        \AxiomC{$\Gamma_{111}$}
        \UnaryInfC{$\alpha_{111}$}
        \DisplayProof    
      \end{minipage}
    };
    \node at (3,0) 
    {
      \ldots
    };
    \node at (5,0) 
    {
      \ldots
    };
    \node at (1,-1.5) 
    {
      \ldots
    };
    %%% edges
    \draw[thick] (1, -1.3) -- (1,0) (5,0.2) -- (5,3) (3,0.2) -- (3,1.5) (1,0) -- (3,1.5) (7,1.7) -- (5,3)  (3,1.5) -- (5,3)  (5,1.5) -- (5,3);
  \end{tikzpicture}
  \caption{Árbol de prueba} \label{arbol}
\end{figure}

Las tácticas modifican el contexto durante una prueba, transformando un secuente en cero o más secuentes. Ver Figura \ref{arbol}.

\subsubsection{Ejemplos}
\label{ejemplos}

Una subprueba se corresponde a un nodo en el árbol de derivación. 
Las tácticas que ingresa el usuario construyen dicho árbol. Cuando se demuestran todas las subpruebas, se obtiene el lambda término final. 

Podemos ver en la Figura \ref{Estados} un diagrama compuesto de todas las subpruebas que se generan al demostrar el
siguiente secuente:
$p, \; q \vee  (p \rightarrow t) \rightarrow  r, \; t, \; p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w \vdash w$.

Empleamos la siguiente notación:\\

\tikz \node[rectangle,draw,label=below:
Estado de $subps$]{Subpruebas};

Donde, $subps$ mantiene los datos de las subpruebas ($subps :: [SubProof]$), y $ty$ retorna el objetivo de la subprueba que recibe como
argumento.
La transición de un estado a otro se realiza mediante una táctica.
Consideramos $C = H0 : p, \; H1 : q \vee  (p \rightarrow t) \rightarrow  r, \; H2 : t, \; H3: p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w$.

\begin{figure}  
  \begin{tikzpicture}[->, node distance=2cm, auto, thick,main node/.style={rectangle,draw}]

    \node[main node, label={[align=left]below:$subps = [s_{0}]$\\$\wedge \; ty \; s_{0} = [w]$}] (1) {$C \vdash  w$};
    \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\ $\wedge \; ty \; s_{1} = [p \wedge q]$ \\ 
      $\wedge \; ty \; s_{0} = [r, q \vee t]$}] 
    (2) [right=of 1] {$C \vdash  p \wedge t$, $C \vdash r$, $C \vdash q \vee t$};
    \begin{scope}[node distance=1.4cm]
      \node[main node, label={[align=left]below:$subps = [s_{2},s_{1},s_{0}]$\\$\wedge \; ty \; s_{2} = [p]$
        \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}]
      (3) [right=of 2] {$C \vdash  p , C \vdash t$, $C \vdash r$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=1cm]
      \coordinate [right=of 3] (4) {};
    \end{scope}
    \begin{scope}[node distance=2.8cm]
      \node[main node, label={[align=left]below:$subps = [s_{1},s_{0}]$ \\$\wedge \; ty \; s_{1} = [t]$ \\ $\wedge \; ty \; s_{0} = [r,q \vee t]$}] 
      (5) [below=of 4] {$C \vdash t$, $C \vdash r$,$C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=2.2cm]
      \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [r]$ \\ $\wedge \; ty \; s_{0} = [q \vee t]$}] 
      (6) [left=of 5] {$C \vdash r$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=1.7cm]
    \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [q \vee  (p \rightarrow t)]$ \\ 
      $\wedge \; ty \; s_{0} = [q \vee t]$}] 
    (7) [left=of 6] {$C \vdash q \vee  (p \rightarrow t)$, $C \vdash q \vee t$};
    \coordinate [left=of 7] (8) {};
    \end{scope}
    \begin{scope}[node distance=2.8cm]
      \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [p \rightarrow t]$ \\ $\wedge \; ty 
        \; s_{0} = [q \vee t]$}] 
      (9) [below=of 8] {$C \vdash p \rightarrow t$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=1.5cm]
      \node[main node, label={[align=left]below:$subps = [s_{3},s_{0}]$ \\$\wedge \; ty \; s_{3} = [t]$ \\ $\wedge \; ty 
        \; s_{0} = [q \vee t]$}] 
      (10) [right=of 9] {$\{C, H4: p \}\vdash t$, $C \vdash q \vee t$};
    \end{scope}
    \begin{scope}[node distance=2.4cm]
      \node[main node, label={[align=left]below:$subps = [s_{0}]$ \\ $\wedge \; ty \; s_{0} = [q \vee t]$}] 
      (11) [right=of 10] {$C \vdash q \vee t$};
      \coordinate [right=of 11] (12) {};
      \node[main node, label={[align=left]below:$subps = [s_{0}]$ \\ $\wedge \; ty \; s_{0} = [t]$}] 
      (13) [below=of 12] {$C \vdash t$};
      \node[main node, label={[align=left]below:$subps = [\;]$}] 
      (14) [left=of 13] {$\emptyset$};
    \end{scope}
    \path[draw] (1) edge [above] node {\texttt{apply H3}} (2) (2) edge [above] node {\texttt{split}} (3)
    (3) -- (4) (4) edge node [left] {\texttt{assumption}} (5) (5) edge node [above] {\texttt{assumption}} (6) 
    (6) edge node [above] {\texttt{apply H1}} (7) (7) -- (8) (8) -- node [right] {\texttt{right}} (9)
    (9) edge node [above] {\texttt{intro}} (10) (10) edge node [above] {\texttt{assumption}} (11)
    (11) -- (12) (12) -- node [left] {\texttt{right}} (13) (13) edge node [above] {\texttt{assumption}} (14);
  \end{tikzpicture}
  \caption{Diagrama de subpruebas. Secuente: 
$p, \; q \vee  (p \rightarrow t) \rightarrow  r, \; t, \; p \wedge t \rightarrow r \rightarrow q \vee t \rightarrow w \vdash w$.
} \label{Estados}
\end{figure}

\begin{table}[]
\centering
\caption{Prueba de $\forall p, \forall q, p \wedge q \rightarrow p$}
\label{Ejemplo}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Tácticas} & \textbf{Lambda término} & \textbf{Derivación} \\ \hline
  \texttt{-}    &     ?          & \AxiomC{}
                            \UnaryInfC{$\forall p, \forall q, p \wedge q \rightarrow p$}
                            \DisplayProof   \\ \hline
  \texttt{intros} & $\lambda p. \lambda q. \lambda H0: p \wedge q. \; ?$ 
                          & \AxiomC{$$}
                            \noLine
                            \UnaryInfC{$p$}
                            \noLine
                            \UnaryInfC{$q$}
                            \noLine
                            \UnaryInfC{$H0: p \wedge q$}
                            \UnaryInfC{$p$}
                            \DisplayProof   \\ \hline
 \texttt{intros; elim H0} 
         & $\lambda p. \lambda q. \lambda H0: p \wedge q. \; elim\_and \; [p] \; [q] \; [p] \; H0 \; ?$
                          & \AxiomC{$$}
                            \noLine
                            \UnaryInfC{$p$}
                            \noLine 
                            \UnaryInfC{$q$}
                            \noLine
                            \UnaryInfC{$H0: p \wedge q$}
                            \UnaryInfC{$p \rightarrow q \rightarrow p$}
                            \DisplayProof   \\ \hline
 \texttt{intros; elim H0; intros}
         & \begin{tabular}[c]{@{}c@{}}$\lambda p. \lambda q. \lambda H0: p \wedge q. \; elim\_and \; [p] \; [q] \; [p]$
             \\ $H0 \; (\lambda H1: p. \lambda H2: q. \; ?)$\end{tabular}
                          & \AxiomC{$$}
                            \noLine
                            \UnaryInfC{$p$}
                            \noLine 
                            \UnaryInfC{$q$}
                            \noLine
                            \UnaryInfC{$H0: p \wedge q$}
                            \noLine
                            \UnaryInfC{$H1: p$}
                            \noLine
                            \UnaryInfC{$H2: q$}
                            \UnaryInfC{$p$}
                            \DisplayProof   \\ \hline
  \begin{tabular}[c]{@{}c@{}}\texttt{intros; elim H0}\\ \texttt{intros; assumption}\end{tabular}
         & \begin{tabular}[c]{@{}c@{}}$\lambda p. \lambda q. \lambda H0: p \wedge q. \; elim\_and \; [p] \; [q] \; [p]$
             \\ $H0 \; (\lambda H1: p. \; \lambda H2: q. \; H1)$\end{tabular}
                          & - \\ \hline

\end{tabular}
\end{table}

En la construcción del lambda término, utilizamos \textit{términos con agujeros}, de modo tal que sucesivas aplicaciones 
de las tácticas armen el término que cumpla con el tipo deseado.

Tomemos como ejemplo la siguiente fórmula: $\forall p, \forall q, p \wedge q \rightarrow p$.
Lo probaremos aplicando reglas de eliminación e introducción mediante el uso de tácticas.

En el Cuadro \ref{Ejemplo}, vemos una prueba del teorema.
La columna \textbf{Tácticas} muestra las tácticas ingresadas. 
La columna \textbf{Lambda término} tiene el lambda término asociado a la prueba, 
y por último \textbf{Derivación} indica la derivación que resta probar una vez procesadas las tácticas.
Vemos que la aplicación de cada táctica corresponde a un lambda término.
Una vez finalizada la prueba, se tiene un lambda término completo.

\section{Comandos}

El asistente de prueba cuenta con un entorno global, el cual llamaremos $GEnv$ (un record de tipo \texttt{GlobalState}).
En este entorno están las variables declaradas.

\begin{verbatim}
> Variables a, b;
\end{verbatim}

Se añaden $a$ y $b$ a $GEnv$. El contexto con el cual inicia una prueba tendrá a las variables $a$ y $b$.

Además, $GEnv$ tiene los teoremas probados.

\begin{verbatim}
> Theorem t1: a -> a;
\end{verbatim}
  
El contexto inicial es $\Gamma_1 = a, \; b$. 

\begin{verbatim}
a1 < intro; assumption;
\end{verbatim}

Cuando la prueba termina se añade a $GEnv$ el nombre del teorema, el tipo, y
la prueba: $t1$, $a \rightarrow a$, $\lambda H0:a. \; H0$.
Luego,  $t1$ puede utilizarse en pruebas posteriores.

En $GEnv$ están los supuestos.

\begin{verbatim}
> Axiom a1: forall p, p \/ ~p;
\end{verbatim}

Se añaden el nombre y el tipo a $GEnv$, es decir, $a1$ y $\forall p, p \vee \neg p$.
De este modo, $a1$ estará disponibles en las siguientes pruebas.

Por último, en $GEnv$ están los operados definidos por el usuario.

\begin{verbatim}
> op1 x = ~ ~ x;
\end{verbatim}

El contexto con el cual inicia cada prueba se obtiene de $GEnv$. Cuando inicia el asistente, $GEnv$ tiene los teoremas
y operadores definidos en \texttt{Prelude.hs}.

Todos los comandos terminan con punto y coma \texttt{``;''}. Es posible escribir varios comandos en la misma entrada,
incluso comandos $incompletos$. Es decir que podemos ir completando el comando. 
Por ejemplo,

\begin{verbatim}
> Theorem 
>* t2 : forall q,
>* q -> q;
\end{verbatim}

Estos son los comandos que definen el lenguaje del asistente de prueba.

\begin{itemize}

\item \texttt{Variables} \textit{var}. Declaración de variables.
\item \textit{name} \texttt{=} \textit{type}. Declaración de un operador.
  Permite definir sinónimos de tipos. 

  Variantes:
  \begin{itemize}
  \item \textit{name} $var_0$ \ldots $var_n$ \texttt{=} \textit{type}.
    Asocia las variables al operador. 

    Es equivalente a escribir:
    \textit{name} \texttt{=} $\forall \; var_0, \; \ldots \; , \forall var_n, \; type$.
  \item $var_0$ \textit{name} $var_1$. Define al operador de manera infija.

    Es equivalente a escribir:
    \textit{name} \texttt{=} $\forall \; var_0, \forall var_1, \; type$.
  \end{itemize}

\item \textit{name} \texttt{=} \textit{lambda term}. Declaración de un lambda término,
se añade al entorno global.

\item \textit{name} \texttt{:} \textit{type}. Asume \textit{type} como un postulado,
se añade al entorno global. Equivale a \texttt{Axiom} \textit{name} \texttt{:} \textit{type}.

\item \texttt{Theorem} \textit{name} \texttt{:} \textit{type}. Inicia la prueba de un
teorema. Cuando la prueba finaliza se la añade a un entorno global, de modo tal que pueda utilizarse en las pruebas de
otros teoremas. 


\item \texttt{Axiom} \textit{name} \texttt{:} \textit{type}. Asume \textit{type} como un postulado.
Equivale a \textit{name} \texttt{:} \textit{type}.

\item \texttt{Print} \textit{name}. Imprime en pantalla la prueba de \textit{name}, si existe.

Variante:
\texttt{Print} \_. Imprime todos los operadores, teoremas y axiomas declarados.

\item \texttt{Check} \textit{lambda term}. Determina el tipo de \textit{lambda term}, si existe.

\item \textit{tactic}. Tácticas, ver sección \ref{tácticas}.

\end{itemize}

Comandos de control: 

\begin{itemize}

\item \texttt{:load} \textit{files}. Carga desde uno o varios archivos.

\item \texttt{:save} \textit{file}. Guarda en un archivo todos los comandos válidos ingresados hasta el momento.

\item \texttt{:abort}. Cancela la prueba actual.

\item \texttt{:quit}. Sale del asistente de prueba.

\item \texttt{:help}. Imprime un mensaje describiendo todos los comandos.

\end{itemize}


\subsection{Tácticas}
\label{tácticas}

A continuación se describen las tácticas de acuerdo a las reglas de inferencias.

\begin{itemize}
\item Caso trivial: táctica \texttt{assumption}, o \texttt{apply H}.   
  
  \AxiomC{$\Gamma$}
  \noLine
  \UnaryInfC{$H:\alpha$}
  \UnaryInfC{$\alpha$}
  \DisplayProof

Corresponde al término $H$.

\item Introducción de la implicancia: táctica \texttt{intro}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \rightarrow \beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $\lambda H:\alpha. \; ?_{1}$, siendo
  $?_{1}$ la prueba de $\beta$.

\item Introducción del para todo: táctica \texttt{intro}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\forall x. \; \beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$x$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $\lambda x. \; ?_{1}$, donde $?_{1}$ es la prueba de $\beta$.

\item Introducción de la disyunción izquierda: táctica \texttt{left}.
  
  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \vee \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}

Corresponde al término $(intro\_or1 \; [\alpha] \; [\beta] \; ?_{1})$, siendo $?_{1}$ la prueba de $\alpha$.

\item Introducción de la disyunción derecha: táctica \texttt{right}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \vee \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}
  
  Corresponde al término $(intro\_or2 \; [\alpha] \; [\beta] \; ?_{1})$, donde $?_{1}$ es la prueba de $\beta$.

\item Introducción de la conjunción: táctica \texttt{split}.

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \wedge \beta$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $(intro\_and \; [\alpha] \; [\beta] \; ?_{1} \; ?_{2})$, donde $?_{1}$ es la prueba de $\alpha$, y $?_{2}$ es la prueba de $\beta$.

\item Introducción del existencial: táctica \texttt{exists $\alpha$}.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$exists \; x, \; \sigma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\sigma [x \rightarrow \alpha]$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término ($\{ ^*\alpha, ?_1 \} \; as \; exists \; x, \; \sigma$), siendo $?_{1}$ la prueba de $\sigma [x \rightarrow \alpha]$. 

\item Introducción del absurdo: táctica \texttt{absurd $\alpha$}. 

  \begin{minipage}[t]{0.13\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$False$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\neg \alpha$}
    \DisplayProof    
  \end{minipage}

  Corresponde a la prueba $(intro\_bottom \; [\alpha] \; ?_{1} \; ?_{2})$, siendo $?_{1}$ la prueba de $\alpha$, 
  y $?_{2}$ la prueba de $\neg \alpha$.

\item Eliminación de la implicancia: táctica \texttt{apply H}.

  \begin{minipage}[t]{0.18\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H:\alpha \rightarrow \beta$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \rightarrow \beta$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}

  Corresponde a la prueba $(H \; ?_{1})$, donde $?_{1}$ es la prueba de $\alpha$.

  La táctica también se puede aplicar en la siguiente situación:

  \begin{minipage}[t]{0.35\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H:\alpha_{1} \rightarrow \alpha_{2} \rightarrow \ldots \rightarrow \alpha_{n} \rightarrow \beta$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.07\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \ldots$}
    \UnaryInfC{$\alpha_{1}$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \ldots$}
    \UnaryInfC{$\alpha_{2}$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.04\linewidth}
    \ldots    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \ldots$}
    \UnaryInfC{$\alpha_{n}$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $(H \; ?_{1} \; \ldots \; ?_{n})$, donde $?_{i}$ es la prueba de $\alpha_{i}$.

\item Eliminación del para todo: táctica \texttt{apply H}.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \forall x. \; \beta$}
    \UnaryInfC{$\gamma$}
    \DisplayProof
  \end{minipage}

  Corresponde al término $(H \; [\theta])$, si existe $\theta$ tal que $\gamma = \beta[x \rightarrow \theta]$.
  
  En términos generales,

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \forall x_{1}. \forall x_{2}. .. \forall x_{n}. \; \beta$}
    \UnaryInfC{$\gamma$}
    \DisplayProof
  \end{minipage}

  Corresponde a la prueba $(H \; [\theta_{1}] [\theta_{2}] \ldots [\theta_{n}])$,
  de modo tal que $\gamma = \beta \; [ x_{1} \rightarrow \theta_{1} ] \ldots [x_{n} \rightarrow \theta_{n}]$, si existen $\theta_{1} \ldots \theta_{n}$.

\item Eliminación de la disyunción: táctica \texttt{elim H}.

  \begin{minipage}[t]{0.18\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \vee \beta$}
    \UnaryInfC{$\sigma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.15\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \vee \beta$}
    \UnaryInfC{$\alpha \rightarrow \sigma$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \vee \beta$}
    \UnaryInfC{$\beta \rightarrow \alpha$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término $(elim\_or \; [\alpha] \; [\beta] \; [\sigma] \; H \; ?_{1} \; ?_{2})$, 
  donde $?_{1}$ es la prueba de $\alpha \rightarrow \sigma$, y $?_{2}$ es la prueba de $\beta \rightarrow \alpha$.

\item Eliminación de la conjunción: táctica \texttt{elim H}.

  \begin{minipage}[t]{0.18\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \wedge \beta$}
    \UnaryInfC{$\sigma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : \alpha \wedge \beta$}
    \UnaryInfC{$\alpha \rightarrow \beta \rightarrow \sigma$}
    \DisplayProof    
  \end{minipage}
  
  Corresponde al término $(elim\_and \; [\alpha] \; [\beta] \; [\sigma] \; H \; ?_1)$, donde $?_{1}$ es la prueba de $\alpha \rightarrow \beta \rightarrow \sigma$.

\item Eliminación del existencial: táctica \texttt{elim H}.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : exists \; x, \; \alpha $}
    \UnaryInfC{$\gamma$}
    \DisplayProof
  \end{minipage}
  \begin{minipage}[t]{0.05\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : exists \; x, \; \alpha $}
    \noLine
    \UnaryInfC{$x$}
    \noLine
    \UnaryInfC{$H' : \alpha$}
    \UnaryInfC{$\gamma$}
    \DisplayProof    
  \end{minipage}

  Corresponde al término ($let \; \{x, H'\} = H \; in \; ?_1$),
  siendo $?_1$ la prueba de $\gamma$.

\item Eliminación del absurdo: táctica \texttt{elim H}.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \noLine
    \UnaryInfC{$H : False$}
    \UnaryInfC{$\sigma$}
    \DisplayProof
  \end{minipage}

  Corresponde al término $(elim\_bottom \; [\sigma] \; H)$.

\end{itemize}

Otras tácticas:

\begin{itemize}

\item Lema intermedio: táctica \texttt{cut $\beta$}.

  \begin{minipage}[t]{0.08\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta \rightarrow \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\beta$}
    \DisplayProof    
  \end{minipage}

  Corresponde a la prueba $(?_{1} \; ?_{2})$, donde $?_1$ es la prueba de $\beta \rightarrow \alpha$, y $?_2$ es la
  prueba de $\beta$.

\item Explicitación de la prueba: táctica \texttt{exact T}.

  \begin{minipage}[t]{0.2\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha$}
    \DisplayProof
  \end{minipage}

  Esta táctica tiene como lambda término asociado a $T$, donde $T$ debe ser una prueba de $\alpha$.
  
\item Eliminación de la definición: táctica \texttt{unfold op}.

  Aplica la definición del operador \texttt{op}. Por ejemplo, \texttt{unfold not} produce lo siguiente,

  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\neg \alpha$}
    \DisplayProof    
  \end{minipage}
  \begin{minipage}[t]{0.08\linewidth}
    $\rightsquigarrow$
  \end{minipage}
  \begin{minipage}[t]{0.1\linewidth}
    \AxiomC{$\Gamma$}
    \UnaryInfC{$\alpha \rightarrow False$}
    \DisplayProof    
  \end{minipage}
  
  Es posible usar $unfold$ en las hipótesis así: \texttt{unfold op in H}, donde \texttt{H} es el nombre de la hipótesis.

\item Introducción de la implicación y del para todo: táctica \texttt{intros}.
  Esta táctica aplica \texttt{intro} hasta que no se pueda seguir aplicando.

\end{itemize}


\section{Módulos}

A continuación se describe brevemente cuales son los aspectos fundamentales que trata cada módulo.

\begin{itemize}

\item \texttt{ErrorMsj}: pretty printer de los mensajes de error.
\item \texttt{Common}: contiene los tipos abstractos de datos principales.
\item \texttt{Proof}: oculta las funciones que operan sobre la construcción de una prueba.
\item \texttt{GlobalState}: tiene funciones que operan sobre datos ``globales'', es decir que son
datos que se mantienen durante toda la ejecución del asistente.
\item \texttt{ProverState}: mantiene el estado general del asistente, incluye los datos de la
construcción de una prueba y los datos globales.
\item \texttt{TypeSubstitution}: oculta el algoritmo de substitución.
\item \texttt{TypeUnification}: oculta la unificación de tipos.
\item \texttt{TypeInference}: oculta la inferencia de tipos.
\item \texttt{TypeDefinition}: contiene funciones que operan sobre el entorno de tipos.
\item \texttt{LambdaTermDefinition}: tiene funciones que operan sobre el entorno de los lambda términos.
\item \texttt{TermsWithHoles}: oculta el tratamiento de los lambda términos con agujeros.
\item \texttt{Hyphotesis}: tiene funciones relacionadas con las hipótesis.
\item \texttt{RenamedVariables}: oculta el algoritmo de renombramiento utilizado sobre los nombres de la hipótesis.
\item \texttt{Transformers}: mantiene las transformaciones de lambda términos y tipos.
\item \texttt{Tactics}: se encarga de construir una prueba a partir de una táctica.
\item \texttt{PrettyPrinter}: pretty printer general del asistente.
\item \texttt{Parser}: parser del lenguaje.
\item \texttt{Main}: procesa el comando de entrada. 
\item \texttt{PreludePath}: oculta la ubicación del archivo \texttt{Prelude.pr}.

\end{itemize}


\section{Gramáticas}

Veremos algunas de las gramáticas más importantes del lenguaje.
Gramática del lambda calculo:

\begin{tabbing}
$\langle lamTerm \rangle$ \hspace{0.5cm} \= $::=$ $\langle abs \rangle$ | $\langle app \rangle$ 
\Big( $\langle abs \rangle$ | $\varepsilon$ \Big) \\

$\langle app \rangle$ \> $::=$ $\langle app \rangle$ $\Big($ \texttt{'['} $\langle typeTerm \rangle$ \texttt{']'} 
| $\langle unitTerm \rangle \; \Big)$ 
| $\langle unitTerm \rangle$ \\

$\langle unitTerm \rangle$ \> $::=$ $\langle unitaryTerm \rangle$ $\Big($ \texttt{'as'} $\langle typeTerm \rangle \; 
| \; \varepsilon \; \Big)$ \\

$\langle unitaryTerm \rangle$ \> $::=$ \texttt{'('} $\langle lamTerm \rangle$ \texttt{')'} 
| $\langle var \rangle$ \\

$\langle abs \rangle$ \> $::=$ \texttt{'$\lambda$'} $\langle var \rangle$ $\Big($ \texttt{':'} $\langle typeTerm \rangle$ \texttt{'.'} 
$\langle lamTerm \rangle$ | \texttt{'.'} $\langle lamTerm \rangle \; \Big)$ \\
\> | \texttt{'\{' '*'} $\langle typeTerm \rangle$ \texttt{','} $\langle lamTerm \rangle$ \texttt{'\}' 'as'} $\langle typeTerm \rangle$ \\
\> | \texttt{'let' '\{'} $\langle var \rangle$ \texttt{','} $\langle var \rangle$ \texttt{'\}' '='} $\langle lamTerm \rangle$ \texttt{'in'}
$\langle lamTerm \rangle$

\end{tabbing}

Consideramos a $\langle var \rangle$, como la gramática de palabras alfanuméricas, (incluido el guión bajo) 
exceptuando las palabras reservadas: \texttt{Theorem}, \texttt{forall}, \texttt{False}, etc.

Gramática de fórmulas o tipos:

\begin{tabbing}

$\langle typeTerm \rangle$ \hspace{0.3cm} \= $::=$ $\langle unit_{1} \rangle$ $\Big($ \texttt{'<->'} $\langle typeTerm \rangle$ | $\varepsilon \; \Big)$\\
$\langle unit_{1} \rangle$ \> $::=$ $\langle unit_{2} \rangle$ $\Big($ \texttt{'->'} $\langle unit_{1} \rangle$ | $\varepsilon$ $\Big)$ \\
$\langle unit_{2} \rangle$ \> $::=$ $\langle unit_{3} \rangle$ $\Big($ \texttt{'\textbackslash/'} $\langle unit_{2} \rangle$ 
| $\varepsilon$ $\Big)$ \\
$\langle unit_{3} \rangle$ \> $::=$ $\langle infixOps \rangle$ $\Big($ \texttt{'/\textbackslash'} $\langle unit_{3} \rangle$ 
| $\varepsilon$ $\Big)$ \\
$\langle unit_{4} \rangle$ \> $::=$ \texttt{'$\sim$'} $\langle unit_{4} \rangle$ 
| $\langle prefixOps \rangle$ | $\langle unit_{5} \rangle$ | $\langle quantifiers \rangle$\\
$\langle unit_{5} \rangle$ \> $::=$ \texttt{'('} $\langle typeTerm \rangle$ \texttt{')'} | \texttt{False} | $\langle var \rangle$  \\
$\langle infixOps \rangle$ \> $::=$ $\langle unit_{4} \rangle$ $\Big($ $\langle symbol \rangle$ $\langle infixOps \rangle$ $\Big)$ 
| $\varepsilon$\\
$\langle prefixOps \rangle$ \> $::=$ $\langle prefixOps \rangle$ $\langle unit_{5} \rangle$ | $\langle app \rangle$\\
$\langle app \rangle$ \> $::=$ \texttt{'('} $\langle prefixOps \rangle$ \texttt{')'} | $\langle symbol \rangle$ | $\langle var \rangle$ \\
$\langle quantifiers \rangle$ \> $::=$ $\Big($ \texttt{'forall'} | \texttt{'exists'} $\Big)$ $\langle var \rangle$ \texttt{','} $\langle typeTerm \rangle$ \\
\end{tabbing}

Tenemos que $\langle symbol \rangle$ es la gramática de símbolos, mas precisamente se tratan de caracteres de símbolos Unicode, 
incluye símbolos matemáticos, de moneda y los caracteres \texttt{\textbackslash}, \texttt{/}, y \texttt{-}, exceptuando a los
símbolos: \texttt{\textbackslash/}, \texttt{/\textbackslash}, etc.

Precedencia de los operadores:

\setlist[enumerate,1]{start=0}
\begin{enumerate}

\item \textit{Prefix operators}, $\mathtt{\sim}$
\item \textit{Binary infix operators}
\item \texttt{/\textbackslash}
\item \texttt{\textbackslash/}
\item \texttt{->}
\item \texttt{<->}
\item \texttt{forall}, \texttt{exists} 

\end{enumerate}

Los operadores con un valor de precedencia alto tienen menos precedencia que otro con un valor más bajo.
Por ejemplo, \texttt{/\textbackslash} tiene más precedencia que \texttt{\textbackslash/}.

Consideramos a \textit{Prefix operators} como el conjunto de los todos los operadores prefijos definidos por el usuario,
donde todos ellos tienen la misma precedencia.
Mientras que \textit{Binary infix operators} es el conjunto de los operadores binarios infijos dados por el usuario,
donde todos ellos mantienen la misma precedencia.

Todos los operadores binarios infijos asocian a derecha.


\section{Observaciones}
Cuando se ingresa un tipo o fórmula, posiblemente se lo renombre, de modo tal de que éste respete la siguiente
convención.
  
\textbf{Convención 1}: Sea \textit{t} un tipo. 
En \textit{t} no se declaran dos variables de tipo ligadas con el mismo nombre, una más anidada que la otra.
Además, $BV (t) \cap (\Gamma_{t} \cup Props) = \emptyset$. Donde, $\Gamma_{t}$ es el conjunto de variables de tipo del contexto, y $Props$ es el conjunto
de variables de tipos libres.

La \textbf{Convención 1} se aplica al tipo del \textit{goal}.

Esta convención nos permite evitar la captura de variables. 
Cuando implementamos el comando \texttt{unfold}, nos aseguramos que el tipo resultado de la sustitución, respete la \textbf{Convención 1}.
Además, sabemos que en el entorno de variables de tipos no se tiene la misma variable más de dos veces, gracias al renombramiento.
% Por ello, al aplicar la táctica \texttt{intro} sobre un ``para todo'', no es necesario chequear que no la variable de tipo ligada
% no se encuentre en el contexto de tipos, pues ya sabemos que no está allí, gracias al renombramiento de variables de tipos ligadas.

La función \texttt{habitar} se encarga de construir el lambda término asociado a la prueba que va dando el usuario.
A cada regla de la deducción natural del sistema IFC, le corresponde una regla de tipo, en el lambda cálculo simplemente
tipado. ¿Como construimos el término $t$, asociado a una prueba lógica?.
A cada aplicación de una regla de tipo, le corresponde un lambda término ``vació''.
Es decir, si se busca un lambda término de tipo $\beta \rightarrow \gamma$, por ejemplo, y se lo quiere construir mediante la regla 
de tipo \textbf{T-Abs}, entonces, tenemos el término vació, $t_{1} = \lambda x:\beta. \; ?$, donde $? : \gamma$.
Representamos a los términos vacíos, mediante funciones, en el caso anterior, tendríamos la función:

\begin{verse}
  $t_{1}$ :: \texttt{Term} $\rightarrow$  \texttt{Term} \\
  $t_{1}$ $t$ = $\lambda x:\beta. \; t$
\end{verse}

Donde, \texttt{Term} es el tipo de los lambda términos. El argumento que se le pase a $t_{1}$, debería tener tipo $\gamma$.
Esto se chequea de acuerdo a qué regla de tipo quiere aplicar el usuario.
Por lo tanto, $t = (t_{1} . t_{2} \dots t_{n-2} . t_{n-1}) \; t_{n}$, donde $t_{n}$ es un lambda término no vació, que sirve de argumento a la composiciones
de funciones. Cada $t_{i}$, con $i \in \{ 1 \dots n \}$, se corresponde con una regla de tipado, que a su vez se corresponde con una regla de deducción natural, 
que da el usuario.

En la implementación de la regla de tipado, correspondiente a la introducción del existe, consideramos que $t_{2}$ debe tener un tipo equivalente
a $T_{2}[X:=U]$, llamemos lo $T$. Es decir que $T$ puede variar de $T_{2}[X:=U]$, con respecto a los nombres de las variables de tipo ligadas que aparecen en 
el segundo.
Hacemos esto para respetar la \textbf{Convención 1}. 
  
El tipo $T$ lo calcula la función \texttt{applyTypes}. Para ello, realiza la sustitución $T_{2}[X:=U]$, más un renombramiento que respete la \textbf{Convención 1}.
Ver Ejemplo 7, en los casos de inferencia OK.
  
Consideramos dos espacios de nombres para las variables.
\begin{itemize}
\item $v.términos = v.ligadas_{te} \cup v.libres_{te}$
\item $v.libres_{te} = teoremas$
\item $v.tipos = v.ligadas_{ti} \cup v.libres_{ti}$
\item $v.libres_{ti} = proposiciones \cup operadores$
\end{itemize}

Donde, $v.ligadas_{ti} \cap v.libres_{ti} = \emptyset$, para satisfacer la \textbf{Convención 1}.
Además, $v.libres_{te} \cap v.libres_{ti} = \emptyset$, para desambiguar las aplicaciones de variables.

También, consideramos para cada prueba, $hipótesis \cap teoremas = \emptyset$. De lo contrario, tendríamos conflictos de nombres.


\begin{thebibliography}{9}
\bibitem{pierce} 
  Benjamin C. Pierce. 
  Types and Programming Languages. 2002.

\bibitem{languageEng}
  Ana Bove, Luís Soares Barbosa,
  Alberto Pardo, y
  Jorge Sousa Pinto.
  Language Engineering and Rigorous Software Development.
  Springer, 2009.

\bibitem{curry-howard}
  Morten Heine Sørensen, y Pawel Urzyczyn.
  Lectures on the Curry-Howard Isomorphism.
  2006

\end{thebibliography}


\end{document}
