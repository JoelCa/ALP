Dependencias (Viejo)

cabal install mtl
cabal install exceptions


Observaciones

- Para parsear la string "\", hice el truco: [head "\\"].
CUIDADO!. Si se quiere probar el parser por el interprete usar [head "\\"] en lugar de "\".
Ej: getCommand ("Theorem a : a /" ++ [head "\\"]++ "a.")

- (PROBAR) Emplee unificación de solo un nivel, por ejemplo esto no se puede probar:
  Theorem qqq: p->(forall p, forall p, p) -> forall p, p.

- Problema dado por Mauro en agda: ~(A <-> ~A)
Resuelto en Coq.

Theorem paradox: ~(A <-> ~A).
Proof.
  unfold iff, not.
  intros.
  elim H.
  intros;
  apply H0;
  apply H1;
  intro;
  apply H0;
  assumption;
  assumption.
Qed.

- YA NO VALE. Cuando se aplica la introducción del "para todo" sobre la variable de tipo "x", se reemplaza
en el tipo sin nombre el término "TBound 0" por "TFree x". Es util cuando se comparan tipos
en el comando "assumption".


- El lambda término final tiene un tipo alpha equivalente al dado por el usuario.
Por ejemplo, si el tipo es: (forall k, k -> k) -> (forall j, j) -> (forall y, y).
Se tiene el lambda término \x:(forall k, k -> k).x (forall j, j), el cual tendría tipo
(forall k, k -> k) -> (forall j, j) -> (forall j, j)

- Definimos cada una de la reglas de la semántica de tipos del sistema F, mediante términos con aujeros.
De modo tal que sucesivas aplicaciones de los axiomas terminen de armar el lambda término que cumpla
con el tipo deseado. 
Sabemos que el sistema F, permite la abstracción tanto términos como tipos. Así podemos definir nuevos 
constructores de tipos, a partir del lenguaje, sin necesidad de incoorporarlo ad hoc.
Hacemos uso del poder expresivo del sistema F, definiendo los tipos (u operadores lógicos) "and" y "or",
en término de los tipos del sistema F.

- ¿Por qué es necesario declarar las proposiciones (o variables de tipo)?. Lo hacemos para tener un
un mejor algoritmo de reescritura de variables de tipos ligadas sobre el tipo que da el usuario.

- Casos de pruebas para el inferidor de tipos:
Válidos:
infer \d.\a.\x: a -> d.\b.\y:b.x.
infer \a.\b.\x:a->b.\c.\y:a->c.\d.\z:a->b.y.
infer \a.\b.\w:a->b.(\c.\x:a->c.\d.\y:forall o, d->c. y [d]) [a].

Inválidos:
infer (\a.\x:a.\a.\b.\y:a->b. (y) x).

- El inferidos de tipo permite superposición de variables ligadas.
Por ej: infer \a.\x:a.\a.\b.\y:a->b. (y) x.

- Aquellas variables de tipo que declaramos, mediante el comando "Props", aparecen como variables
de tipo libre en el lambda término que las utiliza.

- La unificación, con el comando "apply", sobre una variable de término H, trata de unificar 
todos los "para todos" seguidos más externos de H. En algunos casos, basta con encontrar la 
unificación solo para algunos "para todos".

- Utilizé las estructuras de datos Map y Seq.

- Utilizé el tipo de datos Doc, como pretty printer.

- Casos para probar la definición de tipos:
Definition c1 x := ~(x /\  (forall w, w)) \/ x.

- ARREGLAR:
El siguiente caso no parsea bien el teorema:
Definition x x y := forall w, forall v, x /\ y (infix).
Theorem tt2 : forall w, forall y, w x y -> w x y.
Se arregla con paréntesis:
Theorem tt2 : forall w, forall y, (w x y) -> w x y.

- Tanto "~" como "<->", están definidos de manera "hardcode".

